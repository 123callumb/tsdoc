{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../tsdoc/lib/details/ModifierTagSet.js","webpack:///../tsdoc/lib/details/StandardModifierTagSet.js","webpack:///../tsdoc/lib/details/StandardTags.js","webpack:///../tsdoc/lib/index.js","webpack:///../tsdoc/lib/nodes/DocBlock.js","webpack:///../tsdoc/lib/nodes/DocBlockTag.js","webpack:///../tsdoc/lib/nodes/DocCodeSpan.js","webpack:///../tsdoc/lib/nodes/DocComment.js","webpack:///../tsdoc/lib/nodes/DocDeclarationReference.js","webpack:///../tsdoc/lib/nodes/DocErrorText.js","webpack:///../tsdoc/lib/nodes/DocEscapedText.js","webpack:///../tsdoc/lib/nodes/DocFencedCode.js","webpack:///../tsdoc/lib/nodes/DocHtmlAttribute.js","webpack:///../tsdoc/lib/nodes/DocHtmlEndTag.js","webpack:///../tsdoc/lib/nodes/DocHtmlStartTag.js","webpack:///../tsdoc/lib/nodes/DocInheritDocTag.js","webpack:///../tsdoc/lib/nodes/DocInlineTag.js","webpack:///../tsdoc/lib/nodes/DocLinkTag.js","webpack:///../tsdoc/lib/nodes/DocMemberIdentifier.js","webpack:///../tsdoc/lib/nodes/DocMemberReference.js","webpack:///../tsdoc/lib/nodes/DocMemberSelector.js","webpack:///../tsdoc/lib/nodes/DocMemberSymbol.js","webpack:///../tsdoc/lib/nodes/DocNode.js","webpack:///../tsdoc/lib/nodes/DocNodeContainer.js","webpack:///../tsdoc/lib/nodes/DocNodeLeaf.js","webpack:///../tsdoc/lib/nodes/DocParagraph.js","webpack:///../tsdoc/lib/nodes/DocParamBlock.js","webpack:///../tsdoc/lib/nodes/DocParticle.js","webpack:///../tsdoc/lib/nodes/DocPlainText.js","webpack:///../tsdoc/lib/nodes/DocSection.js","webpack:///../tsdoc/lib/nodes/DocSoftBreak.js","webpack:///../tsdoc/lib/nodes/index.js","webpack:///../tsdoc/lib/parser/Excerpt.js","webpack:///../tsdoc/lib/parser/LineExtractor.js","webpack:///../tsdoc/lib/parser/NodeParser.js","webpack:///../tsdoc/lib/parser/ParagraphSplitter.js","webpack:///../tsdoc/lib/parser/ParserContext.js","webpack:///../tsdoc/lib/parser/ParserMessage.js","webpack:///../tsdoc/lib/parser/ParserMessageLog.js","webpack:///../tsdoc/lib/parser/StringChecks.js","webpack:///../tsdoc/lib/parser/TSDocParser.js","webpack:///../tsdoc/lib/parser/TSDocParserConfiguration.js","webpack:///../tsdoc/lib/parser/TSDocTagDefinition.js","webpack:///../tsdoc/lib/parser/TextRange.js","webpack:///../tsdoc/lib/parser/Token.js","webpack:///../tsdoc/lib/parser/TokenReader.js","webpack:///../tsdoc/lib/parser/TokenSequence.js","webpack:///../tsdoc/lib/parser/Tokenizer.js","webpack:///../tsdoc/lib/renderers/PlainTextRenderer.js","webpack:///../tsdoc/lib/transforms/DocNodeTransforms.js","webpack:///../tsdoc/lib/transforms/TrimSpacesTransform.js","webpack:///./src/index.css","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./src/index.css?d8c3","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./src/PlaygroundView.tsx","webpack:///./src/App.tsx","webpack:///./src/index.tsx","webpack:///external \"React\"","webpack:///external \"ReactDOM\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,+EAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;;;;;;ACzEa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,gEAAkB;AACjD,qBAAqB,mBAAO,CAAC,4DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kD;;;;;;;;;;;;;AC/Fa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,+EAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;ACrWa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,oEAAwB;AACrD;AACA,+BAA+B,mBAAO,CAAC,wFAAkC;AACzE;AACA,uBAAuB,mBAAO,CAAC,wEAA0B;AACzD;AACA,SAAS,mBAAO,CAAC,4CAAS;AAC1B,gBAAgB,mBAAO,CAAC,wDAAkB;AAC1C;AACA,sBAAsB,mBAAO,CAAC,oEAAwB;AACtD;AACA,sBAAsB,mBAAO,CAAC,oEAAwB;AACtD;AACA,yBAAyB,mBAAO,CAAC,0EAA2B;AAC5D;AACA,kBAAkB,mBAAO,CAAC,4DAAoB;AAC9C;AACA,cAAc,mBAAO,CAAC,oDAAgB;AACtC;AACA;AACA,sBAAsB,mBAAO,CAAC,oEAAwB;AACtD;AACA,oBAAoB,mBAAO,CAAC,gEAAsB;AAClD;AACA,iCAAiC,mBAAO,CAAC,0FAAmC;AAC5E;AACA;AACA,2BAA2B,mBAAO,CAAC,8EAA6B;AAChE;AACA;AACA,0BAA0B,mBAAO,CAAC,oFAAgC;AAClE;AACA,iC;;;;;;;;;;;;;ACrCa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,sDAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;;ACzDa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C,qBAAqB,mBAAO,CAAC,mEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;;AChEa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;;AC5Ea;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,mBAAmB,mBAAO,CAAC,sDAAc;AACzC,+BAA+B,mBAAO,CAAC,yFAAmC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;;AC9Ea;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mD;;;;;;;;;;;;;ACjIa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;AC/Ea;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;;;;;;AC1Ea;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;ACzGa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;;ACvHa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;AC3Ea;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2C;;;;;;;;;;;;;AChHa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,qBAAqB,mBAAO,CAAC,0DAAgB;AAC7C;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;;ACvEa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,qBAAqB,mBAAO,CAAC,mEAAwB;AACrD,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA,2CAA2C,YAAY,OAAO,MAAM;AACpE;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4CAA4C;AAC3F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,4CAA4C;AAC3F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;AClHa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,qBAAqB,mBAAO,CAAC,0DAAgB;AAC7C,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;;ACjJa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C,qBAAqB,mBAAO,CAAC,mEAAwB;AACrD;AACA,qCAAqC,yBAAyB;AAC9D;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+C;;;;;;;;;;;;;AC3Ga;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA,MAAM,sDAAsD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8C;;;;;;;;;;;;;AClJa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C,qBAAqB,mBAAO,CAAC,mEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,OAAO;AACzF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;;ACvHa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAA6C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2C;;;;;;;;;;;;;AC/Ea;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;;ACzCa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC;AACA;AACA,kDAAkD,mBAAmB,MAAM,iBAAiB;AAC5F;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB,MAAM,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;;AC3Fa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;;ACvDa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;ACzDa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,kDAAY;AACrC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;ACxEa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,gDAAW;AACnC,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;;AC1Fa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;AC7Da;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,0DAAgB;AAC7C,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;;ACnEa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;AC5Ca;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,kDAAY;AAC7B,SAAS,mBAAO,CAAC,wDAAe;AAChC,SAAS,mBAAO,CAAC,4DAAiB;AAClC,SAAS,mBAAO,CAAC,wDAAe;AAChC,SAAS,mBAAO,CAAC,sDAAc;AAC/B,SAAS,mBAAO,CAAC,gFAA2B;AAC5C,SAAS,mBAAO,CAAC,0DAAgB;AACjC,SAAS,mBAAO,CAAC,8DAAkB;AACnC,SAAS,mBAAO,CAAC,kEAAoB;AACrC,SAAS,mBAAO,CAAC,4DAAiB;AAClC,SAAS,mBAAO,CAAC,gEAAmB;AACpC,SAAS,mBAAO,CAAC,0DAAgB;AACjC,SAAS,mBAAO,CAAC,kEAAoB;AACrC,SAAS,mBAAO,CAAC,sDAAc;AAC/B,SAAS,mBAAO,CAAC,wEAAuB;AACxC,SAAS,mBAAO,CAAC,sEAAsB;AACvC,SAAS,mBAAO,CAAC,oEAAqB;AACtC,SAAS,mBAAO,CAAC,gEAAmB;AACpC,SAAS,mBAAO,CAAC,gDAAW;AAC5B,SAAS,mBAAO,CAAC,kEAAoB;AACrC,SAAS,mBAAO,CAAC,wDAAe;AAChC,SAAS,mBAAO,CAAC,0DAAgB;AACjC,SAAS,mBAAO,CAAC,4DAAiB;AAClC,SAAS,mBAAO,CAAC,wDAAe;AAChC,SAAS,mBAAO,CAAC,0DAAgB;AACjC,SAAS,mBAAO,CAAC,sDAAc;AAC/B,SAAS,mBAAO,CAAC,0DAAgB;AACjC,iC;;;;;;;;;;;;;AChCa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;;ACzBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;AC1Ja;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,6CAAS;AAC/B,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,cAAc,mBAAO,CAAC,6CAAU;AAChC,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,gBAAgB,mBAAO,CAAC,iDAAW;AACnC,oBAAoB,mBAAO,CAAC,yDAAe;AAC3C,qBAAqB,mBAAO,CAAC,2DAAgB;AAC7C,2BAA2B,mBAAO,CAAC,uEAAsB;AACzD,qBAAqB,mBAAO,CAAC,qEAAyB;AACtD,0BAA0B,mBAAO,CAAC,mFAAgC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oDAAoD;AAC5G,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2HAA2H,2BAA2B,EAAE;AACxJ;AACA;AACA,+HAA+H,+BAA+B,EAAE;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6BAA6B;AAC7E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8HAA8H;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6GAA6G;AAC7G;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA,oDAAoD;AACpD;AACA;AACA;AACA,6GAA6G;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wHAAwH;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,KAAK;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qJAAqJ;AACrJ;AACA;AACA,4EAA4E;AAC5E;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;;ACtjDa;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,6CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0BAA0B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;;AChHa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,cAAc,mBAAO,CAAC,6CAAU;AAChC,yBAAyB,mBAAO,CAAC,mEAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;AChCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;ACvDa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;;ACtEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;;AC7Ha;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,mBAAmB,mBAAO,CAAC,uDAAc;AACzC,iCAAiC,mBAAO,CAAC,mFAA4B;AACrE,0BAA0B,mBAAO,CAAC,qEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;;ACrCa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qEAAyB;AACtD;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8CAA8C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,YAAY,+DAA+D;AAC3E;AACA;AACA;AACA,4DAA4D,gCAAgC,EAAE;AAC9F,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAgD;AAC9D;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,2DAA2D,8BAA8B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAgD;AAC9D;AACA;AACA,2DAA2D,8BAA8B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oD;;;;;;;;;;;;;AC5La;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,2DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8C;;;;;;;;;;;;;ACvCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;;ACrHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,iC;;;;;;;;;;;;;ACtKa;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,6CAAS;AAC/B,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE,qBAAqB,EAAE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;;AC5Ka;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAA2D;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;;ACjGa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,cAAc,mBAAO,CAAC,6CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,+BAA+B,aAAa,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,YAAY,EAAE;AACpF;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;;AC/Ia;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,6CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,4BAA4B,mBAAO,CAAC,6EAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iDAAiD;AAC3D,UAAU;AACV,UAAU,oCAAoC;AAC9C,UAAU;AACV,UAAU,0BAA0B,aAAa,GAAG;AACpD,UAAU,uCAAuC;AACjD,UAAU,8BAA8B;AACxC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0CAA0C;AACpD,UAAU,kCAAkC;AAC5C,UAAU,0BAA0B,aAAa,GAAG;AACpD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;;ACvDa;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,6CAAU;AAChC,gBAAgB,mBAAO,CAAC,yDAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA,+C;;;;;;;;;;;;ACxIA,2BAA2B,mBAAO,CAAC,6FAA4C;AAC/E;;;AAGA;AACA,cAAc,QAAS,SAAS,oBAAoB,iBAAiB,8BAA8B,KAAK;;AAExG;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;;AAElE;AACA;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,uDAAQ;;AAE9B;AACA,KAAK,IAAqC;AAC1C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA,mBAAmB,2BAA2B;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA,QAAQ,uBAAuB;AAC/B;AACA;AACA,GAAG;AACH;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,kDAAkD,sBAAsB;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,KAAK,KAAwC,EAAE,EAE7C;;AAEF,QAAQ,sBAAiB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;;AAEA,6BAA6B,mBAAmB;;AAEhD;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;AC5YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,EAAE;AACrD,wCAAwC,WAAW,EAAE;;AAErD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC,GAAG;AACH;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;;;;;;;;;;;;;ACvFA,cAAc,mBAAO,CAAC,mGAAmD;;AAEzE,4CAA4C,QAAS;;AAErD;AACA;;;;AAIA,eAAe;;AAEf;AACA;;AAEA,aAAa,mBAAO,CAAC,mGAAgD;;AAErE;;AAEA,GAAG,KAAU,EAAE,E;;;;;;;;;;;;;;;;;;;;;;;ACnBf;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEO;AACP;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEO;AACP;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;;AAEO;AACP;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEO;AACP,mCAAmC,oCAAoC;AACvE;;AAEO;AACP;AACA;;AAEO;AACP;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;;AAEO;AACP,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,gBAAgB;AACzC;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEO;AACP,4BAA4B,sBAAsB;AAClD;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA,iBAAiB,sFAAsF,aAAa,EAAE;AACtH,sBAAsB,gCAAgC,qCAAqC,0CAA0C,EAAE,EAAE,GAAG;AAC5I,2BAA2B,MAAM,eAAe,EAAE,YAAY,oBAAoB,EAAE;AACpF,sBAAsB,oGAAoG;AAC1H,6BAA6B,uBAAuB;AACpD,4BAA4B,wBAAwB;AACpD,2BAA2B,yDAAyD;AACpF;;AAEO;AACP;AACA,iBAAiB,4CAA4C,SAAS,EAAE,qDAAqD,aAAa,EAAE;AAC5I,yBAAyB,6BAA6B,oBAAoB,gDAAgD,gBAAgB,EAAE,KAAK;AACjJ;;AAEO;AACP;AACA;AACA,2GAA2G,sFAAsF,aAAa,EAAE;AAChN,sBAAsB,8BAA8B,gDAAgD,uDAAuD,EAAE,EAAE,GAAG;AAClK,4CAA4C,sCAAsC,UAAU,oBAAoB,EAAE,EAAE,UAAU;AAC9H;;AAEO;AACP,gCAAgC,uCAAuC,aAAa,EAAE,EAAE,OAAO,kBAAkB;AACjH;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,4CAA4C;AAC5C;;;;;;;ACzL+B;AACW;AAW1C;IAAoC,kCAA2D;IAI7F,wBAAY,KAA2B,EAAE,OAAa;QAAtD,YACE,kBAAM,KAAK,EAAE,OAAO,CAAC,SAqBtB;QAzBO,yBAAmB,GAAuB,SAAS,CAAC;QACpD,oBAAc,GAAY,IAAI,CAAC;QAKrC,KAAI,CAAC,KAAK,GAAG;YACX,SAAS,EACP;gBACE,KAAK;gBACL,wCAAwC;gBACxC,IAAI;gBACJ,aAAa;gBACb,uFAAuF;gBACvF,IAAI;gBACJ,sCAAsC;gBACtC,uCAAuC;gBACvC,gDAAgD;gBAChD,IAAI;gBACJ,UAAU;gBACV,KAAK;aACN,CAAC,IAAI,CAAC,IAAI,CAAC;YACd,UAAU,EAAE,EAAE;YACd,UAAU,EAAE,EAAE;SACf,CAAC;;IACJ,CAAC;IAEM,0CAAiB,GAAxB;QACE,IAAI,CAAC,mBAAmB,GAAG,WAAW,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;IACpF,CAAC;IAEM,6CAAoB,GAA3B;QACE,IAAI,IAAI,CAAC,mBAAmB,KAAK,SAAS,EAAE;YAC1C,aAAa,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YACxC,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;SACtC;IACH,CAAC;IAEM,+BAAM,GAAb;QACE,IAAM,aAAa,GAAwB;YACzC,KAAK,EAAE,OAAO;YACd,MAAM,EAAE,OAAO;SAChB,CAAC;QACF,IAAM,mBAAmB,GAAwB;YAC/C,KAAK,EAAE,QAAQ;YACf,MAAM,EAAE,OAAO;SAChB,CAAC;QAEF,OAAO,CACL;YACE,+CACE,EAAE,EAAC,gBAAgB,EACnB,KAAK,EAAG,aAAa,EACrB,KAAK,EAAG,IAAI,CAAC,KAAK,CAAC,SAAS,EAC5B,QAAQ,EAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,GAChD;YACJ,+CACE,EAAE,EAAC,iBAAiB,EACpB,QAAQ,EAAG,IAAI,EACf,KAAK,EAAG,IAAI,CAAC,KAAK,CAAC,UAAU,EAC7B,KAAK,EAAG,aAAa,GACnB;YACJ,4CAAM;;YAEN,4CAAM;YACN,+CACE,EAAE,EAAC,iBAAiB,EACpB,QAAQ,EAAG,IAAI,EACf,KAAK,EAAG,IAAI,CAAC,KAAK,CAAC,UAAU,EAC7B,KAAK,EAAG,mBAAmB,GACzB,CACA,CACP,CAAC;IACJ,CAAC;IAEO,gDAAuB,GAA/B,UAAgC,KAA6C;QAC3E,IAAI,CAAC,QAAQ,CAAC;YACZ,SAAS,EAAE,KAAK,CAAC,MAAM,CAAC,KAAK;SAC9B,CAAC,CAAC;QACH,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC7B,CAAC;IAEO,6CAAoB,GAA5B;QACE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACxB,OAAO;SACR;QACD,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,IAAI;YACF,IAAM,SAAS,GAAW,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;YAC/C,IAAM,WAAW,GAAsB,IAAI,kBAAiB,EAAE,CAAC;YAC/D,IAAM,aAAa,GAAwB,WAAW,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;YAE9E,IAAM,UAAU,GAAW,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAC,IAAI,QAAC,CAAC,QAAQ,EAAE,EAAZ,CAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAExF,IAAM,WAAW,GAAa,EAAE,CAAC;YACjC,IAAI,aAAa,CAAC,UAAU,EAAE;gBAC5B,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,aAAa,CAAC,UAAU,CAAC,CAAC;aAC5D;YAED,IAAI,CAAC,QAAQ,CAAC;gBACZ,UAAU,EAAE,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC;gBAClC,UAAU;aACX,CAAC,CAAC;SACJ;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,CAAC,QAAQ,CAAC;gBACZ,UAAU,EAAE,EAAE;gBACd,UAAU,EAAE,uBAAuB,GAAG,KAAK,CAAC,OAAO;aACpD,CAAC,CAAC;SACJ;IACH,CAAC;IAEO,uCAAc,GAAtB,UAAuB,WAAqB,EAAE,OAAsB,EAAE,MAAmB;QAAnB,oCAAmB;QACvF,IAAI,QAAQ,GAAc,MAAM,UAAK,OAAO,CAAC,IAAM,CAAC;QACpD,IAAI,OAAO,YAAY,kBAAiB,IAAI,OAAO,CAAC,OAAO,EAAE;YAC3D,IAAM,OAAO,GAAW,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAC3D,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBACtB,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;aAC5C;SACF;QACD,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE3B,KAAoB,UAAuB,EAAvB,YAAO,CAAC,aAAa,EAAE,EAAvB,cAAuB,EAAvB,IAAuB,EAAE;YAAxC,IAAM,KAAK;YACd,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC;SACxD;IACH,CAAC;IACH,qBAAC;AAAD,CAAC,CA9HmC,4BAAe,GA8HlD;;;;;AC1I8B;AACmB;AAElD;IAAkB,uBAAe;IAAjC;;IAWA,CAAC;IAVQ,oBAAM,GAAb;QAEE,OAAO,CACL;YACE,gEAAyB;YAEzB,iCAAC,6BAAc,OAAG,CACd,CACP,CAAC;IACJ,CAAC;IACH,UAAC;AAAD,CAAC,CAXiB,4BAAe,GAWhC;AAEc,mDAAG,EAAC;;;;;;AChBY;AACO;AACd;AACH;AAErB,4BAAe,CACb,iCAAC,OAAG,OAAG,EACP,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAgB,CAC/C,CAAC;;;;;;;;;;;;;ACRF,aAAa,gCAAgC,EAAE,I;;;;;;;;;;;;ACA/C,aAAa,mCAAmC,EAAE,I","file":"tsdoc-playground.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.tsx\");\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TSDocTagDefinition_1 = require(\"../parser/TSDocTagDefinition\");\r\n/**\r\n * Represents a set of modifier tags that were extracted from a doc comment.\r\n *\r\n * @remarks\r\n * TSDoc modifier tags are block tags that do not have any associated rich text content.\r\n * Instead, their presence or absence acts as an on/off switch, indicating some aspect\r\n * of the underlying API item.  For example, the `@internal` modifier indicates that a\r\n * signature is internal (i.e. not part of the public API contract).\r\n */\r\nvar ModifierTagSet = /** @class */ (function () {\r\n    function ModifierTagSet() {\r\n        this._nodes = [];\r\n        // NOTE: To implement case insensitivity, the keys in this set are always upper-case.\r\n        // This convention makes the normalization more obvious (and as a general practice handles\r\n        // the Turkish \"i\" character correctly).\r\n        this._nodesByName = new Map();\r\n    }\r\n    Object.defineProperty(ModifierTagSet.prototype, \"nodes\", {\r\n        /**\r\n         * The original block tag nodes that defined the modifiers in this set, excluding duplicates.\r\n         */\r\n        get: function () {\r\n            return this._nodes;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns true if the set contains a DocBlockTag with the specified tag name.\r\n     * Note that synonyms are not considered.  The comparison is case-insensitive.\r\n     * @param modifierTagName - The name of the tag, including the `@` prefix  For example, `@internal`\r\n     */\r\n    ModifierTagSet.prototype.hasTagName = function (modifierTagName) {\r\n        return this._nodesByName.has(modifierTagName.toUpperCase());\r\n    };\r\n    /**\r\n     * Returns true if the set contains a DocBlockTag matching the specified tag definition.\r\n     * Note that synonyms are not considered.  The comparison is case-insensitive.\r\n     * The TSDocTagDefinition must be a modifier tag.\r\n     * @param tagName - The name of the tag, including the `@` prefix  For example, `@internal`\r\n     */\r\n    ModifierTagSet.prototype.hasTag = function (modifierTagDefinition) {\r\n        return !!this.tryGetTag(modifierTagDefinition);\r\n    };\r\n    /**\r\n     * Returns a DocBlockTag matching the specified tag definition, or undefined if no such\r\n     * tag was added to the set.  If there were multiple instances, returned object will be\r\n     * the first one to be added.\r\n     */\r\n    ModifierTagSet.prototype.tryGetTag = function (modifierTagDefinition) {\r\n        if (modifierTagDefinition.syntaxKind !== TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag) {\r\n            throw new Error('The tag definition is not a modifier tag');\r\n        }\r\n        return this._nodesByName.get(modifierTagDefinition.tagNameWithUpperCase);\r\n    };\r\n    /**\r\n     * Adds a new modifier tag to the set.  If a tag already exists with the same name,\r\n     * then no change is made, and the return value is false.\r\n     */\r\n    ModifierTagSet.prototype.addTag = function (blockTag) {\r\n        if (this._nodesByName.has(blockTag.tagNameWithUpperCase)) {\r\n            return false;\r\n        }\r\n        this._nodesByName.set(blockTag.tagNameWithUpperCase, blockTag);\r\n        this._nodes.push(blockTag);\r\n        return true;\r\n    };\r\n    return ModifierTagSet;\r\n}());\r\nexports.ModifierTagSet = ModifierTagSet;\r\n//# sourceMappingURL=ModifierTagSet.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ModifierTagSet_1 = require(\"./ModifierTagSet\");\r\nvar StandardTags_1 = require(\"./StandardTags\");\r\n/**\r\n * Extends the ModifierTagSet base class with getters for modifiers that\r\n * are part of the standardized core tags for TSDoc.\r\n */\r\nvar StandardModifierTagSet = /** @class */ (function (_super) {\r\n    __extends(StandardModifierTagSet, _super);\r\n    function StandardModifierTagSet() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Returns true if the `@alpha` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isAlpha = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.alpha);\r\n    };\r\n    /**\r\n     * Returns true if the `@beta` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isBeta = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.beta);\r\n    };\r\n    /**\r\n     * Returns true if the `@eventProperty` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isEventProperty = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.eventProperty);\r\n    };\r\n    /**\r\n     * Returns true if the `@experimental` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isExperimental = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.experimental);\r\n    };\r\n    /**\r\n     * Returns true if the `@internal` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isInternal = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.internal);\r\n    };\r\n    /**\r\n     * Returns true if the `@override` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isOverride = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.override);\r\n    };\r\n    /**\r\n     * Returns true if the `@packageDocumentation` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isPackageDocumentation = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.packageDocumentation);\r\n    };\r\n    /**\r\n     * Returns true if the `@public` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isPublic = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.public);\r\n    };\r\n    /**\r\n     * Returns true if the `@readonly` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isReadonly = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.readonly);\r\n    };\r\n    /**\r\n     * Returns true if the `@sealed` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isSealed = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.sealed);\r\n    };\r\n    /**\r\n     * Returns true if the `@virtual` modifier tag was specified.\r\n     */\r\n    StandardModifierTagSet.prototype.isVirtual = function () {\r\n        return this.hasTag(StandardTags_1.StandardTags.virtual);\r\n    };\r\n    return StandardModifierTagSet;\r\n}(ModifierTagSet_1.ModifierTagSet));\r\nexports.StandardModifierTagSet = StandardModifierTagSet;\r\n//# sourceMappingURL=StandardModifierTagSet.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TSDocTagDefinition_1 = require(\"../parser/TSDocTagDefinition\");\r\n/**\r\n * Tags whose meaning is defined by the TSDoc standard.\r\n */\r\nvar StandardTags = /** @class */ (function () {\r\n    function StandardTags() {\r\n    }\r\n    StandardTags._defineTag = function (parameters) {\r\n        return new TSDocTagDefinition_1.TSDocTagDefinition(parameters);\r\n    };\r\n    /**\r\n     * (Discretionary)\r\n     *\r\n     * Suggested meaning: Designates that an API item's release stage is \"alpha\".\r\n     * It is intended to be used by third-party developers eventually, but has not\r\n     * yet been released.  The tooling may trim the declaration from a public release.\r\n     *\r\n     * Example implementations: API Extractor\r\n     */\r\n    StandardTags.alpha = StandardTags._defineTag({\r\n        tagName: '@alpha',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Discretionary\" /* Discretionary */\r\n    });\r\n    /**\r\n     * (Discretionary)\r\n     *\r\n     * Suggested meaning: Designates that an API item's release stage is \"beta\".\r\n     * It has been released to third-party developers experimentally for the purpose of\r\n     * collecting feedback.  The API should not be used in production, because its contract may\r\n     * change without notice.  The tooling may trim the declaration from a public release,\r\n     * but may include it in a developer preview release.\r\n     *\r\n     * Example implementations: API Extractor\r\n     *\r\n     * Synonyms: `@experimental`\r\n     */\r\n    StandardTags.beta = StandardTags._defineTag({\r\n        tagName: '@beta',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Discretionary\" /* Discretionary */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * This block tag communicates that an API item is no loner supported and may be removed\r\n     * in a future release.  The `@deprecated` tag is followed by a sentence describing\r\n     * the recommended alternative.  It recursively applies to members of the container.\r\n     * For example, if a class is deprecated, then so are all of its members.\r\n     */\r\n    StandardTags.deprecated = StandardTags._defineTag({\r\n        tagName: '@deprecated',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * This block tag is used to document the default value for a field or property,\r\n     * if a value is not assigned explicitly.\r\n     *\r\n     * @remarks\r\n     * This tag should only be used with fields or properties that are members of a class or interface.\r\n     */\r\n    StandardTags.defaultValue = StandardTags._defineTag({\r\n        tagName: '@defaultValue',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * When applied to a class or interface property, this indicates that the property\r\n     * returns an event object that event handlers can be attached to.  The event-handling\r\n     * API is implementation-defined, but typically the property return type would be a class\r\n     * with members such as `addHandler()` and `removeHandler()`.  A documentation tool can\r\n     * display such properties under an \"Events\" heading instead of the usual \"Properties\" heading.\r\n     */\r\n    StandardTags.eventProperty = StandardTags._defineTag({\r\n        tagName: '@eventProperty',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * Indicates a documentation section that should be presented as an example\r\n     * illustrating how to use the API.  It may include a code sample.\r\n     */\r\n    StandardTags.example = StandardTags._defineTag({\r\n        tagName: '@example',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        allowMultiple: true,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Discretionary)\r\n     *\r\n     * Suggested meaning:  Same semantics as `@beta`, but used by tools that don't support\r\n     * an `@alpha` release stage.\r\n     *\r\n     * Example implementations: Angular API documenter\r\n     *\r\n     * Synonyms: `@beta`\r\n     */\r\n    StandardTags.experimental = StandardTags._defineTag({\r\n        tagName: '@experimental',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Discretionary\" /* Discretionary */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * This inline tag is used to automatically generate an API item's documentation by\r\n     * copying it from another API item.  The inline tag parameter contains a reference\r\n     * to the other item, which may be an unrelated class, or even an import from a\r\n     * separate NPM package.\r\n     *\r\n     * TODO: The notation for API item references is still being standardized.  See this issue:\r\n     * https://github.com/Microsoft/tsdoc/issues/9\r\n     */\r\n    StandardTags.inheritDoc = StandardTags._defineTag({\r\n        tagName: '@inheritDoc',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.InlineTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Discretionary)\r\n     *\r\n     * Suggested meaning:  Designates that an API item is not planned to be used by\r\n     * third-party developers.  The tooling may trim the declaration from a public release.\r\n     * In some implementations, certain designated packages may be allowed to consume\r\n     * internal API items, e.g. because the packages are components of the same product.\r\n     *\r\n     * Example implementations: API Extractor\r\n     */\r\n    StandardTags.internal = StandardTags._defineTag({\r\n        tagName: '@internal',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Discretionary\" /* Discretionary */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * The `{@label}` inline tag is used to label a declaration, so that it can be referenced\r\n     * using a selector in the TSDoc declaration reference notation.\r\n     *\r\n     * TODO: The `{@label}` notation is still being standardized.  See this issue:\r\n     * https://github.com/Microsoft/tsdoc/issues/9\r\n     */\r\n    StandardTags.label = StandardTags._defineTag({\r\n        tagName: '@label',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.InlineTag,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * The `{@link}` inline tag is used to create hyperlinks to other pages in a\r\n     * documentation system or general internet URLs.  In particular, it supports\r\n     * expressions for referencing API items.\r\n     *\r\n     * TODO: The `{@link}` notation is still being standardized.  See this issue:\r\n     * https://github.com/Microsoft/tsdoc/issues/9\r\n     */\r\n    StandardTags.link = StandardTags._defineTag({\r\n        tagName: '@link',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.InlineTag,\r\n        allowMultiple: true,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * This modifier has similar semantics to the `override` keyword in C# or Java.\r\n     * For a member function or property, explicitly indicates that this definition\r\n     * is overriding (i.e. redefining) the definition inherited from the base class.\r\n     * The base class definition would normally be marked as `virtual`.\r\n     *\r\n     * A documentation tool may enforce that the `@virtual`, `@override`, and/or `@sealed`\r\n     * modifiers are consistently applied, but this is not required by the TSDoc standard.\r\n     */\r\n    StandardTags.override = StandardTags._defineTag({\r\n        tagName: '@override',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * Used to indicate a doc comment that describes an entire NPM package (as opposed\r\n     * to an individual API item belonging to that package).  The `@packageDocumentation` comment\r\n     * is found in the *.d.ts file that acts as the entry point for the package, and it\r\n     * should be the first `/**` comment encountered in that file.  A comment containing a\r\n     * `@packageDocumentation` tag should never be used to describe an individual API item.\r\n     */\r\n    StandardTags.packageDocumentation = StandardTags._defineTag({\r\n        tagName: '@packageDocumentation',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * Used to document a function parameter.  The `@param` tag is followed by a parameter\r\n     * name, followed by a hyphen, followed by a description.  The TSDoc parser recognizes\r\n     * this syntax and will extract it into a DocParamBlock node.\r\n     */\r\n    StandardTags.param = StandardTags._defineTag({\r\n        tagName: '@param',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        allowMultiple: true,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * Starts a section of additional documentation content that is not intended for a\r\n     * public audience.  A tool must omit this entire section from the API reference web site,\r\n     * generated *.d.ts file, and any other outputs incorporating the content.\r\n     */\r\n    StandardTags.privateRemarks = StandardTags._defineTag({\r\n        tagName: '@privateRemarks',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Discretionary)\r\n     *\r\n     * Suggested meaning: Designates that an API item's release stage is \"public\".\r\n     * It has been officially released to third-party developers, and its signature is\r\n     * guaranteed to be stable (e.g. following Semantic Versioning rules).\r\n     *\r\n     * Example implementations: API Extractor\r\n     */\r\n    StandardTags.public = StandardTags._defineTag({\r\n        tagName: '@public',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Discretionary\" /* Discretionary */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * This modifier tag indicates that an API item should be documented as being read-only,\r\n     * even if the TypeScript type system may indicate otherwise.  For example, suppose a\r\n     * class property has a setter function that always throws an exception explaining that\r\n     * the property cannot be assigned; in this situation, the `@readonly` modifier can be\r\n     * added so that the property is shown as read-only in the documentation.\r\n     *\r\n     * Example implementations: API Extractor\r\n     */\r\n    StandardTags.readonly = StandardTags._defineTag({\r\n        tagName: '@readonly',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * The main documentation for an API item is separated into a brief \"summary\" section,\r\n     * optionally followed by a more detailed \"remarks\" section.  On a documentation web site,\r\n     * index pages (e.g. showing members of a class) will show only the brief summaries,\r\n     * whereas a detail pages (e.g. describing a single member) will show the summary followed\r\n     * by the remarks.  The `@remarks` block tag ends the summary section, and begins the\r\n     * remarks section for a doc comment.\r\n     */\r\n    StandardTags.remarks = StandardTags._defineTag({\r\n        tagName: '@remarks',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * Used to document the return value for a function.\r\n     */\r\n    StandardTags.returns = StandardTags._defineTag({\r\n        tagName: '@returns',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * This modifier has similar semantics to the `sealed` keyword in C# or Java.\r\n     * For a class, indicates that subclasses must not inherit from the class.\r\n     * For a member function or property, indicates that subclasses must not override\r\n     * (i.e. redefine) the member.\r\n     *\r\n     * A documentation tool may enforce that the `@virtual`, `@override`, and/or `@sealed`\r\n     * modifiers are consistently applied, but this is not required by the TSDoc standard.\r\n     */\r\n    StandardTags.sealed = StandardTags._defineTag({\r\n        tagName: '@sealed',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * (Core)\r\n     *\r\n     * Used to document a generic parameter.  The `@typeParam` tag is followed by a parameter\r\n     * name, followed by a hyphen, followed by a description.  The TSDoc parser recognizes\r\n     * this syntax and will extract it into a DocParamBlock node.\r\n     */\r\n    StandardTags.typeParam = StandardTags._defineTag({\r\n        tagName: '@typeParam',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag,\r\n        allowMultiple: true,\r\n        standardization: \"Core\" /* Core */\r\n    });\r\n    /**\r\n     * (Extended)\r\n     *\r\n     * This modifier has similar semantics to the `virtual` keyword in C# or Java.\r\n     * For a member function or property, explicitly indicates that subclasses may override\r\n     * (i.e. redefine) the member.\r\n     *\r\n     * A documentation tool may enforce that the `@virtual`, `@override`, and/or `@sealed`\r\n     * modifiers are consistently applied, but this is not required by the TSDoc standard.\r\n     */\r\n    StandardTags.virtual = StandardTags._defineTag({\r\n        tagName: '@virtual',\r\n        syntaxKind: TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag,\r\n        standardization: \"Extended\" /* Extended */\r\n    });\r\n    /**\r\n     * Returns the full list of all core tags.\r\n     */\r\n    StandardTags.allDefinitions = [\r\n        StandardTags.alpha,\r\n        StandardTags.beta,\r\n        StandardTags.deprecated,\r\n        StandardTags.defaultValue,\r\n        StandardTags.eventProperty,\r\n        StandardTags.example,\r\n        StandardTags.experimental,\r\n        StandardTags.inheritDoc,\r\n        StandardTags.internal,\r\n        StandardTags.label,\r\n        StandardTags.link,\r\n        StandardTags.override,\r\n        StandardTags.packageDocumentation,\r\n        StandardTags.param,\r\n        StandardTags.privateRemarks,\r\n        StandardTags.public,\r\n        StandardTags.readonly,\r\n        StandardTags.remarks,\r\n        StandardTags.returns,\r\n        StandardTags.sealed,\r\n        StandardTags.typeParam,\r\n        StandardTags.virtual\r\n    ];\r\n    return StandardTags;\r\n}());\r\nexports.StandardTags = StandardTags;\r\n//# sourceMappingURL=StandardTags.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StandardTags_1 = require(\"./details/StandardTags\");\r\nexports.StandardTags = StandardTags_1.StandardTags;\r\nvar StandardModifierTagSet_1 = require(\"./details/StandardModifierTagSet\");\r\nexports.StandardModifierTagSet = StandardModifierTagSet_1.StandardModifierTagSet;\r\nvar ModifierTagSet_1 = require(\"./details/ModifierTagSet\");\r\nexports.ModifierTagSet = ModifierTagSet_1.ModifierTagSet;\r\n__export(require(\"./nodes\"));\r\nvar Excerpt_1 = require(\"./parser/Excerpt\");\r\nexports.Excerpt = Excerpt_1.Excerpt;\r\nvar ParserContext_1 = require(\"./parser/ParserContext\");\r\nexports.ParserContext = ParserContext_1.ParserContext;\r\nvar ParserMessage_1 = require(\"./parser/ParserMessage\");\r\nexports.ParserMessage = ParserMessage_1.ParserMessage;\r\nvar ParserMessageLog_1 = require(\"./parser/ParserMessageLog\");\r\nexports.ParserMessageLog = ParserMessageLog_1.ParserMessageLog;\r\nvar TextRange_1 = require(\"./parser/TextRange\");\r\nexports.TextRange = TextRange_1.TextRange;\r\nvar Token_1 = require(\"./parser/Token\");\r\nexports.Token = Token_1.Token;\r\nexports.TokenKind = Token_1.TokenKind;\r\nvar TokenSequence_1 = require(\"./parser/TokenSequence\");\r\nexports.TokenSequence = TokenSequence_1.TokenSequence;\r\nvar TSDocParser_1 = require(\"./parser/TSDocParser\");\r\nexports.TSDocParser = TSDocParser_1.TSDocParser;\r\nvar TSDocParserConfiguration_1 = require(\"./parser/TSDocParserConfiguration\");\r\nexports.TSDocParserConfiguration = TSDocParserConfiguration_1.TSDocParserConfiguration;\r\nexports.TSDocParserValidationConfiguration = TSDocParserConfiguration_1.TSDocParserValidationConfiguration;\r\nvar TSDocTagDefinition_1 = require(\"./parser/TSDocTagDefinition\");\r\nexports.TSDocTagSyntaxKind = TSDocTagDefinition_1.TSDocTagSyntaxKind;\r\nexports.TSDocTagDefinition = TSDocTagDefinition_1.TSDocTagDefinition;\r\nvar DocNodeTransforms_1 = require(\"./transforms/DocNodeTransforms\");\r\nexports.DocNodeTransforms = DocNodeTransforms_1.DocNodeTransforms;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocSection_1 = require(\"./DocSection\");\r\n/**\r\n * Represents a section that is introduced by a TSDoc block tag.\r\n * For example, an `@example` block.\r\n */\r\nvar DocBlock = /** @class */ (function (_super) {\r\n    __extends(DocBlock, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocBlock(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"Block\" /* Block */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocBlock.prototype, \"blockTag\", {\r\n        /**\r\n         * The TSDoc tag that introduces this section.\r\n         */\r\n        get: function () {\r\n            return this._blockTag;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocBlock.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._blockTag = parameters.blockTag;\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocBlock.prototype.getChildNodes = function () {\r\n        return [this.blockTag].concat(_super.prototype.getChildNodes.call(this));\r\n    };\r\n    return DocBlock;\r\n}(DocSection_1.DocSection));\r\nexports.DocBlock = DocBlock;\r\n//# sourceMappingURL=DocBlock.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\nvar StringChecks_1 = require(\"../parser/StringChecks\");\r\n/**\r\n * Represents a TSDoc block tag such as `@param` or `@public`.\r\n */\r\nvar DocBlockTag = /** @class */ (function (_super) {\r\n    __extends(DocBlockTag, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocBlockTag(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"BlockTag\" /* BlockTag */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocBlockTag.prototype, \"tagName\", {\r\n        /**\r\n         * The TSDoc tag name.  TSDoc tag names start with an at-sign (\"@\") followed\r\n         * by ASCII letters using \"camelCase\" capitalization.\r\n         */\r\n        get: function () {\r\n            return this._tagName;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocBlockTag.prototype, \"tagNameWithUpperCase\", {\r\n        /**\r\n         * The TSDoc tag name in all capitals, which is used for performing\r\n         * case-insensitive comparisons or lookups.\r\n         */\r\n        get: function () {\r\n            return this._tagNameWithUpperCase;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocBlockTag.prototype.updateParameters = function (parameters) {\r\n        StringChecks_1.StringChecks.validateTSDocTagName(parameters.tagName);\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._tagName = parameters.tagName;\r\n        this._tagNameWithUpperCase = this.tagName.toUpperCase();\r\n    };\r\n    return DocBlockTag;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocBlockTag = DocBlockTag;\r\n//# sourceMappingURL=DocBlockTag.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents CommonMark-style code span, i.e. code surrounded by\r\n * backtick characters.\r\n */\r\nvar DocCodeSpan = /** @class */ (function (_super) {\r\n    __extends(DocCodeSpan, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocCodeSpan(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"CodeSpan\" /* CodeSpan */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocCodeSpan.prototype, \"code\", {\r\n        /**\r\n         * The text that should be rendered as code, excluding the backtick delimiters.\r\n         */\r\n        get: function () {\r\n            return this._codeParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocCodeSpan.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._openingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'openingDelimiter',\r\n            excerpt: parameters.openingDelimiterExcerpt,\r\n            content: '`'\r\n        });\r\n        this._codeParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'code',\r\n            excerpt: parameters.codeExcerpt,\r\n            content: parameters.code\r\n        });\r\n        this._closingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'closingDelimiter',\r\n            excerpt: parameters.closingDelimiterExcerpt,\r\n            content: '`'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocCodeSpan.prototype.getChildNodes = function () {\r\n        return [\r\n            this._openingDelimiterParticle,\r\n            this._codeParticle,\r\n            this._closingDelimiterParticle\r\n        ];\r\n    };\r\n    return DocCodeSpan;\r\n}(DocNode_1.DocNode));\r\nexports.DocCodeSpan = DocCodeSpan;\r\n//# sourceMappingURL=DocCodeSpan.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocSection_1 = require(\"./DocSection\");\r\nvar StandardModifierTagSet_1 = require(\"../details/StandardModifierTagSet\");\r\n/**\r\n * Represents an entire documentation comment conforming to the TSDoc structure.\r\n * This is the root of the DocNode tree.\r\n */\r\nvar DocComment = /** @class */ (function (_super) {\r\n    __extends(DocComment, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocComment(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"Comment\" /* Comment */;\r\n        _this.summarySection = new DocSection_1.DocSection(parameters);\r\n        _this.remarksBlock = undefined;\r\n        _this.privateRemarks = undefined;\r\n        _this.deprecatedBlock = undefined;\r\n        _this.paramBlocks = [];\r\n        _this.typeParamBlocks = [];\r\n        _this.returnsBlock = undefined;\r\n        _this.modifierTagSet = new StandardModifierTagSet_1.StandardModifierTagSet();\r\n        _this._customBlocks = [];\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocComment.prototype, \"customBlocks\", {\r\n        /**\r\n         * The collection of all DocBlock nodes belonging to this doc comment.\r\n         */\r\n        get: function () {\r\n            return this._customBlocks;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Append an item to the customBlocks collection.\r\n     */\r\n    DocComment.prototype.appendCustomBlock = function (block) {\r\n        this._customBlocks.push(block);\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocComment.prototype.getChildNodes = function () {\r\n        return DocNode_1.DocNode.trimUndefinedNodes([\r\n            this.summarySection,\r\n            this.remarksBlock,\r\n            this.privateRemarks,\r\n            this.deprecatedBlock\r\n        ].concat(this.paramBlocks, this.typeParamBlocks, [\r\n            this.returnsBlock\r\n        ], this._customBlocks, [\r\n            this.inheritDocTag\r\n        ], this.modifierTagSet.nodes));\r\n    };\r\n    return DocComment;\r\n}(DocNode_1.DocNode));\r\nexports.DocComment = DocComment;\r\n//# sourceMappingURL=DocComment.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents a declaration reference.\r\n *\r\n * @remarks\r\n * Declaration references are TSDoc expressions used by tags such as `{@link}`\r\n * or `{@inheritDoc}` that need to refer to another declaration.\r\n */\r\nvar DocDeclarationReference = /** @class */ (function (_super) {\r\n    __extends(DocDeclarationReference, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocDeclarationReference(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"DeclarationReference\" /* DeclarationReference */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocDeclarationReference.prototype, \"packageName\", {\r\n        /**\r\n         * The optional package name, which may optionally include an NPM scope.\r\n         *\r\n         * Example: `\"@scope/my-package\"`\r\n         */\r\n        get: function () {\r\n            if (this._packageNameParticle) {\r\n                return this._packageNameParticle.content;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocDeclarationReference.prototype, \"importPath\", {\r\n        /**\r\n         * The optional import path.  If a package name is provided, then if an import path is provided,\r\n         * the path must start with a \"/\" delimiter; otherwise paths are resolved relative to the source file\r\n         * containing the reference.\r\n         *\r\n         * Example: `\"/path1/path2\"`\r\n         * Example: `\"./path1/path2\"`\r\n         * Example: `\"../path2/path2\"`\r\n         */\r\n        get: function () {\r\n            if (this._importPathParticle) {\r\n                return this._importPathParticle.content;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocDeclarationReference.prototype, \"memberReferences\", {\r\n        /**\r\n         * The chain of member references that indicate the declaration being referenced.\r\n         * If this list is empty, then either the packageName or importPath must be provided,\r\n         * because the reference refers to a module.\r\n         */\r\n        get: function () {\r\n            return this._memberReferences;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocDeclarationReference.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._packageNameParticle = undefined;\r\n        this._importPathParticle = undefined;\r\n        this._importHashParticle = undefined;\r\n        if (parameters.packageName) {\r\n            this._packageNameParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'packageName',\r\n                content: parameters.packageName,\r\n                excerpt: parameters.packageNameExcerpt\r\n            });\r\n        }\r\n        if (parameters.importPath) {\r\n            this._importPathParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'importPath',\r\n                content: parameters.importPath || '',\r\n                excerpt: parameters.importPathExcerpt\r\n            });\r\n        }\r\n        if ((parameters.packageName && this._importPathParticle) || parameters.importHashExcerpt) {\r\n            this._importHashParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'importHash',\r\n                content: '#',\r\n                excerpt: parameters.importHashExcerpt\r\n            });\r\n        }\r\n        this._memberReferences = parameters.memberReferences || [];\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocDeclarationReference.prototype.getChildNodes = function () {\r\n        return DocNode_1.DocNode.trimUndefinedNodes([\r\n            this._packageNameParticle,\r\n            this._importPathParticle,\r\n            this._importHashParticle\r\n        ].concat(this._memberReferences));\r\n    };\r\n    return DocDeclarationReference;\r\n}(DocNode_1.DocNode));\r\nexports.DocDeclarationReference = DocDeclarationReference;\r\n//# sourceMappingURL=DocDeclarationReference.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\n/**\r\n * Represents a span of text that contained invalid markup.\r\n * The characters should be rendered as plain text.\r\n */\r\nvar DocErrorText = /** @class */ (function (_super) {\r\n    __extends(DocErrorText, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocErrorText(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"ErrorText\" /* ErrorText */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocErrorText.prototype, \"text\", {\r\n        /**\r\n         * The characters that should be rendered as plain text because they\r\n         * could not be parsed successfully.\r\n         */\r\n        get: function () {\r\n            return this._text;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocErrorText.prototype, \"errorMessage\", {\r\n        /**\r\n         * A description of why the character could not be parsed.\r\n         */\r\n        get: function () {\r\n            return this._errorMessage;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocErrorText.prototype, \"errorLocation\", {\r\n        /**\r\n         * The range of characters that caused the error.  In general these may be\r\n         * somewhat farther ahead in the input stream from the DocErrorText node itself.\r\n         *\r\n         * @remarks\r\n         * For example, for the malformed HTML tag `<a href=\"123\" @ /a>`, the DocErrorText node\r\n         * will correspond to the `<` character that looked like an HTML tag, whereas the\r\n         * error location might be the `@` character that caused the trouble.\r\n         */\r\n        get: function () {\r\n            return this._errorLocation;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocErrorText.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._text = parameters.text;\r\n        this._errorMessage = parameters.errorMessage;\r\n        this._errorLocation = parameters.errorLocation;\r\n    };\r\n    return DocErrorText;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocErrorText = DocErrorText;\r\n//# sourceMappingURL=DocErrorText.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\n/**\r\n * The style of escaping to be used with DocEscapedText.\r\n */\r\nvar EscapeStyle;\r\n(function (EscapeStyle) {\r\n    /**\r\n     * Use a backslash symbol to escape the character.\r\n     */\r\n    EscapeStyle[EscapeStyle[\"CommonMarkBackslash\"] = 0] = \"CommonMarkBackslash\";\r\n})(EscapeStyle = exports.EscapeStyle || (exports.EscapeStyle = {}));\r\n/**\r\n * Represents a text character that should be escaped as a TSDoc symbol.\r\n * @remarks\r\n * Note that renders will normally apply appropriate escaping when rendering\r\n * DocPlainText in a format such as HTML or TSDoc.  The DocEscapedText node\r\n * forces a specific escaping that may not be the default.\r\n */\r\nvar DocEscapedText = /** @class */ (function (_super) {\r\n    __extends(DocEscapedText, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocEscapedText(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"EscapedText\" /* EscapedText */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocEscapedText.prototype, \"escapeStyle\", {\r\n        /**\r\n         * The style of escaping to be performed.\r\n         */\r\n        get: function () {\r\n            return this._escapeStyle;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocEscapedText.prototype, \"text\", {\r\n        /**\r\n         * The text content to be escaped.\r\n         */\r\n        get: function () {\r\n            return this._text;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocEscapedText.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._escapeStyle = parameters.escapeStyle;\r\n        this._text = parameters.text;\r\n    };\r\n    return DocEscapedText;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocEscapedText = DocEscapedText;\r\n//# sourceMappingURL=DocEscapedText.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents CommonMark-style code fence, i.e. a block of program code that\r\n * starts and ends with a line comprised of three backticks.  The opening delimiter\r\n * can also specify a language for a syntax highlighter.\r\n */\r\nvar DocFencedCode = /** @class */ (function (_super) {\r\n    __extends(DocFencedCode, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocFencedCode(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"FencedCode\" /* FencedCode */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocFencedCode.prototype, \"language\", {\r\n        /**\r\n         * A name that can optionally be included after the opening code fence delimiter,\r\n         * on the same line as the three backticks.  This name indicates the programming language\r\n         * for the code, which a syntax highlighter may use to style the code block.\r\n         *\r\n         * @remarks\r\n         * The TSDoc standard requires that the language \"ts\" should be interpreted to mean TypeScript.\r\n         * Other languages names may be supported, but this is implementation dependent.\r\n         *\r\n         * CommonMark refers to this field as the \"info string\".\r\n         *\r\n         * @privateRemarks\r\n         * Examples of language strings supported by GitHub flavored markdown:\r\n         * https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml\r\n         */\r\n        get: function () {\r\n            return this._languageParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocFencedCode.prototype, \"code\", {\r\n        /**\r\n         * The text that should be rendered as code.\r\n         */\r\n        get: function () {\r\n            return this._codeParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocFencedCode.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._openingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'openingDelimiter',\r\n            excerpt: parameters.openingDelimiterExcerpt,\r\n            content: '```'\r\n        });\r\n        this._languageParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'language',\r\n            excerpt: parameters.languageExcerpt,\r\n            content: parameters.language || ''\r\n        });\r\n        this._codeParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'code',\r\n            excerpt: parameters.codeExcerpt,\r\n            content: parameters.code\r\n        });\r\n        this._closingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'closingDelimiter',\r\n            excerpt: parameters.closingDelimiterExcerpt,\r\n            content: '```'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocFencedCode.prototype.getChildNodes = function () {\r\n        return [\r\n            this._openingDelimiterParticle,\r\n            this._languageParticle,\r\n            this._codeParticle,\r\n            this._closingDelimiterParticle\r\n        ];\r\n    };\r\n    return DocFencedCode;\r\n}(DocNode_1.DocNode));\r\nexports.DocFencedCode = DocFencedCode;\r\n//# sourceMappingURL=DocFencedCode.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents an HTML attribute inside a DocHtmlStartTag or DocHtmlEndTag.\r\n *\r\n * Example: `href=\"#\"` inside `<a href=\"#\" />`\r\n */\r\nvar DocHtmlAttribute = /** @class */ (function (_super) {\r\n    __extends(DocHtmlAttribute, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocHtmlAttribute(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"HtmlAttribute\" /* HtmlAttribute */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocHtmlAttribute.prototype, \"attributeName\", {\r\n        /**\r\n         * The HTML attribute name.\r\n         */\r\n        get: function () {\r\n            return this._attributeNameParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlAttribute.prototype, \"spacingAfterAttributeName\", {\r\n        /**\r\n         * Explicit whitespace that a renderer should insert after the HTML attribute name.\r\n         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.\r\n         */\r\n        get: function () {\r\n            return this._attributeNameParticle.spacingAfterContent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlAttribute.prototype, \"spacingAfterEquals\", {\r\n        /**\r\n         * Explicit whitespace that a renderer should insert after the \"=\".\r\n         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.\r\n         */\r\n        get: function () {\r\n            return this._equalsParticle.spacingAfterContent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlAttribute.prototype, \"attributeValue\", {\r\n        /**\r\n         * The HTML attribute value.\r\n         */\r\n        get: function () {\r\n            return this._attributeValueParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlAttribute.prototype, \"spacingAfterAttributeValue\", {\r\n        /**\r\n         * Explicit whitespace that a renderer should insert after the HTML attribute name.\r\n         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.\r\n         */\r\n        get: function () {\r\n            return this._attributeValueParticle.spacingAfterContent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocHtmlAttribute.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._attributeNameParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'attributeName',\r\n            excerpt: parameters.attributeNameExcerpt,\r\n            content: parameters.attributeName,\r\n            spacingAfterContent: parameters.spacingAfterAttributeName\r\n        });\r\n        this._equalsParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'equals',\r\n            excerpt: parameters.equalsExcerpt,\r\n            content: '=',\r\n            spacingAfterContent: parameters.spacingAfterEquals\r\n        });\r\n        this._attributeValueParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'attributeValue',\r\n            excerpt: parameters.attributeValueExcerpt,\r\n            content: parameters.attributeValue,\r\n            spacingAfterContent: parameters.spacingAfterAttributeValue\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocHtmlAttribute.prototype.getChildNodes = function () {\r\n        return [this._attributeNameParticle, this._equalsParticle, this._attributeValueParticle];\r\n    };\r\n    return DocHtmlAttribute;\r\n}(DocNode_1.DocNode));\r\nexports.DocHtmlAttribute = DocHtmlAttribute;\r\n//# sourceMappingURL=DocHtmlAttribute.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents an HTML end tag.  Example: `</a>`\r\n */\r\nvar DocHtmlEndTag = /** @class */ (function (_super) {\r\n    __extends(DocHtmlEndTag, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocHtmlEndTag(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"HtmlEndTag\" /* HtmlEndTag */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocHtmlEndTag.prototype, \"elementName\", {\r\n        /**\r\n         * The HTML element name.\r\n         */\r\n        get: function () {\r\n            return this._elementNameParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocHtmlEndTag.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._openingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'openingDelimiter',\r\n            excerpt: parameters.openingDelimiterExcerpt,\r\n            content: '</'\r\n        });\r\n        this._elementNameParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'elementName',\r\n            excerpt: parameters.elementNameExcerpt,\r\n            content: parameters.elementName\r\n        });\r\n        this._closingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'closingDelimiter',\r\n            excerpt: parameters.closingDelimiterExcerpt,\r\n            content: '>'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocHtmlEndTag.prototype.getChildNodes = function () {\r\n        return [\r\n            this._openingDelimiterParticle,\r\n            this._elementNameParticle,\r\n            this._closingDelimiterParticle\r\n        ];\r\n    };\r\n    return DocHtmlEndTag;\r\n}(DocNode_1.DocNode));\r\nexports.DocHtmlEndTag = DocHtmlEndTag;\r\n//# sourceMappingURL=DocHtmlEndTag.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents an HTML start tag, which may or may not be self-closing.\r\n *\r\n * Example: `<a href=\"#\" />`\r\n */\r\nvar DocHtmlStartTag = /** @class */ (function (_super) {\r\n    __extends(DocHtmlStartTag, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocHtmlStartTag(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"HtmlStartTag\" /* HtmlStartTag */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocHtmlStartTag.prototype, \"elementName\", {\r\n        /**\r\n         * The HTML element name.\r\n         */\r\n        get: function () {\r\n            return this._elementNameParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlStartTag.prototype, \"htmlAttributes\", {\r\n        /**\r\n         * The HTML attributes belonging to this HTML element.\r\n         */\r\n        get: function () {\r\n            return this._htmlAttributes;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlStartTag.prototype, \"selfClosingTag\", {\r\n        /**\r\n         * If true, then the HTML tag ends with \"/>\" instead of \">\".\r\n         */\r\n        get: function () {\r\n            return this._selfClosingTag;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocHtmlStartTag.prototype, \"spacingAfterElementName\", {\r\n        /**\r\n         * Explicit whitespace that a renderer should insert after the HTML element name.\r\n         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.\r\n         */\r\n        get: function () {\r\n            return this._elementNameParticle.spacingAfterContent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocHtmlStartTag.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._openingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'openingDelimiter',\r\n            excerpt: parameters.openingDelimiterExcerpt,\r\n            content: '<'\r\n        });\r\n        this._elementNameParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'elementName',\r\n            excerpt: parameters.elementNameExcerpt,\r\n            content: parameters.elementName,\r\n            spacingAfterContent: parameters.spacingAfterElementName\r\n        });\r\n        this._htmlAttributes = parameters.htmlAttributes;\r\n        this._selfClosingTag = parameters.selfClosingTag;\r\n        this._closingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'closingDelimiter',\r\n            excerpt: parameters.closingDelimiterExcerpt,\r\n            content: parameters.selfClosingTag ? '/>' : '>'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocHtmlStartTag.prototype.getChildNodes = function () {\r\n        return [\r\n            this._openingDelimiterParticle,\r\n            this._elementNameParticle\r\n        ].concat(this._htmlAttributes, [\r\n            this._closingDelimiterParticle\r\n        ]);\r\n    };\r\n    return DocHtmlStartTag;\r\n}(DocNode_1.DocNode));\r\nexports.DocHtmlStartTag = DocHtmlStartTag;\r\n//# sourceMappingURL=DocHtmlStartTag.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocInlineTag_1 = require(\"./DocInlineTag\");\r\n/**\r\n * Represents an `{@inheritDoc}` tag.\r\n */\r\nvar DocInheritDocTag = /** @class */ (function (_super) {\r\n    __extends(DocInheritDocTag, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocInheritDocTag(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"InheritDocTag\" /* InheritDocTag */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocInheritDocTag.prototype, \"declarationReference\", {\r\n        /**\r\n         * The declaration that the documentation will be inherited from.\r\n         * If omitted, the documentation will be inherited from the parent class.\r\n         */\r\n        get: function () {\r\n            return this._declarationReference;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocInheritDocTag.prototype.updateParameters = function (parameters) {\r\n        if (parameters.tagName.toUpperCase() !== '@INHERITDOC') {\r\n            throw new Error('DocInheritDocTag requires the tag name to be \"{@inheritDoc}\"');\r\n        }\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._declarationReference = parameters.declarationReference;\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocInheritDocTag.prototype.getChildNodesForContent = function () {\r\n        if (this.tagContentParticle.excerpt) {\r\n            // If the parser associated the inline tag input with the tagContentExcerpt (e.g. because\r\n            // second stage parsing encountered an error), then fall back to the base class's representation\r\n            return _super.prototype.getChildNodesForContent.call(this);\r\n        }\r\n        else {\r\n            // Otherwise return the detailed structure\r\n            return DocNode_1.DocNode.trimUndefinedNodes([\r\n                this._declarationReference\r\n            ]);\r\n        }\r\n    };\r\n    return DocInheritDocTag;\r\n}(DocInlineTag_1.DocInlineTag));\r\nexports.DocInheritDocTag = DocInheritDocTag;\r\n//# sourceMappingURL=DocInheritDocTag.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar StringChecks_1 = require(\"../parser/StringChecks\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents a TSDoc inline tag such as `{@inheritDoc}` or `{@link}`.\r\n */\r\nvar DocInlineTag = /** @class */ (function (_super) {\r\n    __extends(DocInlineTag, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocInlineTag(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"InlineTag\" /* InlineTag */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocInlineTag.prototype, \"tagName\", {\r\n        /**\r\n         * The TSDoc tag name.\r\n         * For example, if the inline tag is `{@link Guid.toString | the toString() method}`\r\n         * then the tag name would be `@link`.\r\n         */\r\n        get: function () {\r\n            return this._tagNameParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocInlineTag.prototype, \"tagContent\", {\r\n        /**\r\n         * The tag content.\r\n         * For example, if the inline tag is `{@link Guid.toString | the toString() method}`\r\n         * then the tag content would be `Guid.toString | the toString() method`.\r\n         */\r\n        get: function () {\r\n            return this._tagContentParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocInlineTag.prototype.updateParameters = function (parameters) {\r\n        StringChecks_1.StringChecks.validateTSDocTagName(parameters.tagName);\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._openingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'openingDelimiter',\r\n            excerpt: parameters.openingDelimiterExcerpt,\r\n            content: '{'\r\n        });\r\n        this._tagNameParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'tagName',\r\n            excerpt: parameters.tagNameExcerpt,\r\n            content: parameters.tagName\r\n        });\r\n        this._tagContentParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'tagContent',\r\n            excerpt: parameters.tagContentExcerpt,\r\n            content: parameters.tagContent\r\n        });\r\n        this._closingDelimiterParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'closingDelimiter',\r\n            excerpt: parameters.closingDelimiterExcerpt,\r\n            content: '}'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override @sealed\r\n     */\r\n    DocInlineTag.prototype.getChildNodes = function () {\r\n        return [\r\n            this._openingDelimiterParticle,\r\n            this._tagNameParticle\r\n        ].concat(this.getChildNodesForContent(), [\r\n            this._closingDelimiterParticle\r\n        ]);\r\n    };\r\n    /**\r\n     * Allows child classes to replace the tagContentParticle with a more detailed\r\n     * set of nodes.\r\n     * @virtual\r\n     */\r\n    DocInlineTag.prototype.getChildNodesForContent = function () {\r\n        return [\r\n            this._tagContentParticle\r\n        ];\r\n    };\r\n    Object.defineProperty(DocInlineTag.prototype, \"tagContentParticle\", {\r\n        get: function () {\r\n            return this._tagContentParticle;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DocInlineTag;\r\n}(DocNode_1.DocNode));\r\nexports.DocInlineTag = DocInlineTag;\r\n//# sourceMappingURL=DocInlineTag.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocInlineTag_1 = require(\"./DocInlineTag\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents an `{@link}` tag.\r\n */\r\nvar DocLinkTag = /** @class */ (function (_super) {\r\n    __extends(DocLinkTag, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocLinkTag(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"LinkTag\" /* LinkTag */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocLinkTag.prototype, \"codeDestination\", {\r\n        /**\r\n         * If the link tag refers to a declaration, this returns the declaration reference object;\r\n         * otherwise this property is undefined.\r\n         * @remarks\r\n         * Either the `codeDestination` or the `urlDestination` property will be defined, but never both.\r\n         */\r\n        get: function () {\r\n            return this._codeDestination;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocLinkTag.prototype, \"urlDestination\", {\r\n        /**\r\n         * If the link tag was an ordinary URI, this returns the URL string;\r\n         * otherwise this property is undefined.\r\n         * @remarks\r\n         * Either the `codeDestination` or the `urlDestination` property will be defined, but never both.\r\n         */\r\n        get: function () {\r\n            return this._urlDestinationParticle ? this._urlDestinationParticle.content : undefined;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocLinkTag.prototype, \"linkText\", {\r\n        /**\r\n         * An optional text string that is the hyperlink text.  If omitted, the documentation\r\n         * renderer will use a default string based on the link itself (e.g. the URL text\r\n         * or the declaration identifier).\r\n         */\r\n        get: function () {\r\n            if (this._linkTextParticle) {\r\n                return this._linkTextParticle.content;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocLinkTag.prototype.updateParameters = function (parameters) {\r\n        if (parameters.tagName.toUpperCase() !== '@LINK') {\r\n            throw new Error('DocLinkTag requires the tag name to be \"{@link}\"');\r\n        }\r\n        if (parameters.codeDestination !== undefined) {\r\n            if (parameters.urlDestination !== undefined) {\r\n                throw new Error('Either the codeLink or the documentLink may be specified, but not both');\r\n            }\r\n        }\r\n        if (parameters.tagContentExcerpt !== undefined) {\r\n            if (parameters.codeDestination || parameters.urlDestinationExcerpt || parameters.linkTextExcerpt) {\r\n                // This would violate the TokenCoverageChecker properties\r\n                throw new Error('The input cannot be associated with tagContentExcerpt and also the detail excerpts');\r\n            }\r\n        }\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._codeDestination = undefined;\r\n        this._urlDestinationParticle = undefined;\r\n        this._pipeParticle = undefined;\r\n        this._linkTextParticle = undefined;\r\n        if (parameters.codeDestination) {\r\n            this._codeDestination = parameters.codeDestination;\r\n        }\r\n        else if (parameters.urlDestination !== undefined) {\r\n            this._urlDestinationParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'urlDestination',\r\n                excerpt: parameters.urlDestinationExcerpt,\r\n                content: parameters.urlDestination\r\n            });\r\n        }\r\n        if (parameters.linkTextExcerpt || parameters.linkText || parameters.pipeExcerpt) {\r\n            this._pipeParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'pipe',\r\n                excerpt: parameters.pipeExcerpt,\r\n                content: '|'\r\n            });\r\n        }\r\n        if (parameters.linkText !== undefined) {\r\n            this._linkTextParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'linkText',\r\n                excerpt: parameters.linkTextExcerpt,\r\n                content: parameters.linkText\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocLinkTag.prototype.getChildNodesForContent = function () {\r\n        if (this.tagContentParticle.excerpt) {\r\n            // If the parser associated the inline tag input with the tagContentExcerpt (e.g. because\r\n            // second stage parsing encountered an error), then fall back to the base class's representation\r\n            return _super.prototype.getChildNodesForContent.call(this);\r\n        }\r\n        else {\r\n            // Otherwise return the detailed structure\r\n            return DocNode_1.DocNode.trimUndefinedNodes([\r\n                this._urlDestinationParticle,\r\n                this._codeDestination,\r\n                this._pipeParticle,\r\n                this._linkTextParticle\r\n            ]);\r\n        }\r\n    };\r\n    return DocLinkTag;\r\n}(DocInlineTag_1.DocInlineTag));\r\nexports.DocLinkTag = DocLinkTag;\r\n//# sourceMappingURL=DocLinkTag.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\nvar StringChecks_1 = require(\"../parser/StringChecks\");\r\n/**\r\n * A member identifier is part of a {@link DocMemberReference}.\r\n */\r\nvar DocMemberIdentifier = /** @class */ (function (_super) {\r\n    __extends(DocMemberIdentifier, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocMemberIdentifier(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"MemberIdentifier\" /* MemberIdentifier */;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns true if the specified string is a valid TypeScript\r\n     * identifier.  If not, {@link DocMemberIdentifier.hasQuotes} will be\r\n     * required.\r\n     */\r\n    DocMemberIdentifier.isValidIdentifier = function (identifier) {\r\n        return !StringChecks_1.StringChecks.explainIfInvalidUnquotedIdentifier(identifier);\r\n    };\r\n    Object.defineProperty(DocMemberIdentifier.prototype, \"identifier\", {\r\n        /**\r\n         * The identifier string without any quote encoding.\r\n         *\r\n         * @remarks\r\n         * If the value is not a valid ECMAScript identifier, it will be quoted as a\r\n         * string literal during rendering.\r\n         */\r\n        get: function () {\r\n            return this._identifierParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocMemberIdentifier.prototype, \"hasQuotes\", {\r\n        /**\r\n         * Returns true if the identifier will be rendered as a quoted string literal\r\n         * instead of as a programming language identifier.  This is required if the\r\n         * `identifier` property is not a valid ECMAScript identifier.\r\n         */\r\n        get: function () {\r\n            return !!this._leftQuoteParticle;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocMemberIdentifier.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._leftQuoteParticle = undefined;\r\n        this._identifierParticle = undefined;\r\n        this._rightQuoteParticle = undefined;\r\n        if (parameters.leftQuoteExcerpt || !DocMemberIdentifier.isValidIdentifier(parameters.identifier)) {\r\n            this._leftQuoteParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'leftQuote',\r\n                excerpt: parameters.leftQuoteExcerpt,\r\n                content: '\"'\r\n            });\r\n        }\r\n        this._identifierParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'identifier',\r\n            excerpt: parameters.identifierExcerpt,\r\n            content: parameters.identifier\r\n        });\r\n        if (this._leftQuoteParticle) {\r\n            this._rightQuoteParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'rightQuote',\r\n                excerpt: parameters.rightQuoteExcerpt,\r\n                content: '\"'\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocMemberIdentifier.prototype.getChildNodes = function () {\r\n        return DocNode_1.DocNode.trimUndefinedNodes([\r\n            this._leftQuoteParticle,\r\n            this._identifierParticle,\r\n            this._rightQuoteParticle\r\n        ]);\r\n    };\r\n    return DocMemberIdentifier;\r\n}(DocNode_1.DocNode));\r\nexports.DocMemberIdentifier = DocMemberIdentifier;\r\n//# sourceMappingURL=DocMemberIdentifier.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * A {@link DocDeclarationReference | declaration reference} includes a chain of\r\n * member references represented using `DocMemberReference` nodes.\r\n *\r\n * @remarks\r\n * For example, `example-library#ui.controls.Button.(render:static)` is a\r\n * declaration reference that contains three member references:\r\n * `ui`, `.controls`, and `.Button`, and `.(render:static)`.\r\n */\r\nvar DocMemberReference = /** @class */ (function (_super) {\r\n    __extends(DocMemberReference, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocMemberReference(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"MemberReference\" /* MemberReference */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocMemberReference.prototype, \"hasDot\", {\r\n        /**\r\n         * True if this member reference is preceded by a dot (\".\") token.\r\n         * It should be false only for the first member in the chain.\r\n         */\r\n        get: function () {\r\n            return !!this._dotParticle;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocMemberReference.prototype, \"memberIdentifier\", {\r\n        /**\r\n         * The identifier for the referenced member.\r\n         * @remarks\r\n         * Either `memberIdentifier` or `memberSymbol` may be specified, but not both.\r\n         */\r\n        get: function () {\r\n            return this._memberIdentifier;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocMemberReference.prototype, \"memberSymbol\", {\r\n        /**\r\n         * The ECMAScript 6 symbol expression, which may be used instead of an identifier\r\n         * to indicate the referenced member.\r\n         * @remarks\r\n         * Either `memberIdentifier` or `memberSymbol` may be specified, but not both.\r\n         */\r\n        get: function () {\r\n            return this._memberSymbol;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocMemberReference.prototype, \"selector\", {\r\n        /**\r\n         * A TSDoc selector, which may be optionally when the identifier or symbol is insufficient\r\n         * to unambiguously determine the referenced declaration.\r\n         */\r\n        get: function () {\r\n            return this._selector;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocMemberReference.prototype.updateParameters = function (parameters) {\r\n        if (parameters.memberIdentifier && parameters.memberSymbol) {\r\n            throw new Error('\"memberIdentifier\" or \"memberSymbol\" may be specified, but not both');\r\n        }\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._dotParticle = undefined;\r\n        this._leftParenthesisParticle = undefined;\r\n        this._colonParticle = undefined;\r\n        this._selector = undefined;\r\n        this._rightParenthesisParticle = undefined;\r\n        if (parameters.hasDot || parameters.dotExcerpt) {\r\n            this._dotParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'dot',\r\n                excerpt: parameters.dotExcerpt,\r\n                content: '.'\r\n            });\r\n        }\r\n        if (parameters.leftParenthesisExcerpt || parameters.selector) {\r\n            this._leftParenthesisParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'leftParenthesis',\r\n                excerpt: parameters.leftParenthesisExcerpt,\r\n                content: '('\r\n            });\r\n        }\r\n        this._memberIdentifier = parameters.memberIdentifier;\r\n        this._memberSymbol = parameters.memberSymbol;\r\n        if (parameters.colonExcerpt || parameters.selector) {\r\n            this._colonParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'colon',\r\n                excerpt: parameters.colonExcerpt,\r\n                content: ':'\r\n            });\r\n        }\r\n        this._selector = parameters.selector;\r\n        if (this._leftParenthesisParticle) {\r\n            this._rightParenthesisParticle = new DocParticle_1.DocParticle({\r\n                particleId: 'rightParenthesis',\r\n                excerpt: parameters.rightParenthesisExcerpt,\r\n                content: ')'\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocMemberReference.prototype.getChildNodes = function () {\r\n        return DocNode_1.DocNode.trimUndefinedNodes([\r\n            this._dotParticle,\r\n            this._leftParenthesisParticle,\r\n            this._memberIdentifier,\r\n            this._memberSymbol,\r\n            this._colonParticle,\r\n            this._selector,\r\n            this._rightParenthesisParticle\r\n        ]);\r\n    };\r\n    return DocMemberReference;\r\n}(DocNode_1.DocNode));\r\nexports.DocMemberReference = DocMemberReference;\r\n//# sourceMappingURL=DocMemberReference.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\nvar StringChecks_1 = require(\"../parser/StringChecks\");\r\n/**\r\n */\r\nvar DocMemberSelector = /** @class */ (function (_super) {\r\n    __extends(DocMemberSelector, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocMemberSelector(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"MemberSelector\" /* MemberSelector */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocMemberSelector.prototype, \"selector\", {\r\n        /**\r\n         * The text representation of the selector.\r\n         *\r\n         * @remarks\r\n         * For system selectors, it will be a predefined lower case name.\r\n         * For label selectors, it will be an upper case name defined using the `{@label}` tag.\r\n         * For index selectors, it will be a positive integer.\r\n         */\r\n        get: function () {\r\n            return this._selector;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocMemberSelector.prototype, \"selectorKind\", {\r\n        /**\r\n         * Indicates the kind of selector.\r\n         */\r\n        get: function () {\r\n            return this._selectorKind;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocMemberSelector.prototype, \"errorMessage\", {\r\n        /**\r\n         * If the `selectorKind` is `SelectorKind.Error`, this string will be defined and provide\r\n         * more detail about why the string was not valid.\r\n         */\r\n        get: function () {\r\n            return this._errorMessage;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocMemberSelector.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._selector = parameters.selector;\r\n        this._selectorKind = \"error\" /* Error */;\r\n        this._errorMessage = undefined;\r\n        // The logic below will always either (1) assign selectorKind or (2) else assign an errorMessage\r\n        if (this._selector.length === 0) {\r\n            this._errorMessage = 'The selector cannot be an empty string';\r\n        }\r\n        else if (DocMemberSelector._likeIndexSelectorRegExp.test(this._selector)) {\r\n            // It looks like an index selector\r\n            if (DocMemberSelector._indexSelectorRegExp.test(this._selector)) {\r\n                this._selectorKind = \"index\" /* Index */;\r\n            }\r\n            else {\r\n                this._errorMessage = 'If the selector begins with a number, it must be a positive integer value';\r\n            }\r\n        }\r\n        else if (DocMemberSelector._likeLabelSelectorRegExp.test(this._selector)) {\r\n            // It looks like a label selector\r\n            if (DocMemberSelector._labelSelectorRegExp.test(this._selector)) {\r\n                this._selectorKind = \"label\" /* Label */;\r\n            }\r\n            else {\r\n                this._errorMessage = 'A label selector must be comprised of upper case letters, numbers,'\r\n                    + ' and underscores and must not start with a number';\r\n            }\r\n        }\r\n        else {\r\n            if (StringChecks_1.StringChecks.isSystemSelector(this._selector)) {\r\n                this._selectorKind = \"system\" /* System */;\r\n            }\r\n            else if (DocMemberSelector._likeSystemSelectorRegExp.test(this._selector)) {\r\n                // It looks like a system selector, but is not\r\n                this._errorMessage = \"The selector \" + JSON.stringify(this._selector)\r\n                    + \" is not a recognized TSDoc system selector name\";\r\n            }\r\n            else {\r\n                // It doesn't look like anything we recognize\r\n                this._errorMessage = 'Invalid syntax for selector';\r\n            }\r\n        }\r\n    };\r\n    DocMemberSelector._likeIndexSelectorRegExp = /^[0-9]/;\r\n    DocMemberSelector._indexSelectorRegExp = /^[1-9][0-9]*$/;\r\n    DocMemberSelector._likeLabelSelectorRegExp = /^[A-Z_]/u;\r\n    DocMemberSelector._labelSelectorRegExp = /^[A-Z_][A-Z0-9_]+$/;\r\n    DocMemberSelector._likeSystemSelectorRegExp = /^[a-z]+$/u;\r\n    return DocMemberSelector;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocMemberSelector = DocMemberSelector;\r\n//# sourceMappingURL=DocMemberSelector.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents a reference to an ECMAScript 6 symbol that is used\r\n * to identify a member declaration.\r\n *\r\n * @example\r\n *\r\n * In the declaration reference `{@link MyClass.([MySymbols.example]:instance)}`,\r\n * the member symbol `[MySymbols.example]` might be used to reference a property\r\n * of the class.\r\n */\r\nvar DocMemberSymbol = /** @class */ (function (_super) {\r\n    __extends(DocMemberSymbol, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocMemberSymbol(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"MemberSymbol\" /* MemberSymbol */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocMemberSymbol.prototype, \"symbolReference\", {\r\n        /**\r\n         * The declaration reference for the ECMAScript 6 symbol that will act as\r\n         * the identifier for the member.\r\n         */\r\n        get: function () {\r\n            return this._symbolReference;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocMemberSymbol.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._leftBracketParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'leftBracket',\r\n            excerpt: parameters.leftBracketExcerpt,\r\n            content: '['\r\n        });\r\n        this._symbolReference = parameters.symbolReference;\r\n        this._rightBracketParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'rightBracket',\r\n            excerpt: parameters.rightBracketExcerpt,\r\n            content: ']'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocMemberSymbol.prototype.getChildNodes = function () {\r\n        return [\r\n            this._leftBracketParticle,\r\n            this._symbolReference,\r\n            this._rightBracketParticle\r\n        ];\r\n    };\r\n    return DocMemberSymbol;\r\n}(DocNode_1.DocNode));\r\nexports.DocMemberSymbol = DocMemberSymbol;\r\n//# sourceMappingURL=DocMemberSymbol.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * The base class for the parser's Abstract Syntax Tree nodes.\r\n */\r\nvar DocNode = /** @class */ (function () {\r\n    function DocNode(parameters) {\r\n        this.updateParameters(parameters);\r\n    }\r\n    /**\r\n     * Returns the array with any undefined elements removed.\r\n     */\r\n    DocNode.trimUndefinedNodes = function (nodes) {\r\n        return nodes.filter(function (x) { return x; });\r\n    };\r\n    DocNode.validateSpacing = function (spacing, parameterName) {\r\n        if (spacing) {\r\n            var match = DocNode._badSpacingRegExp.exec(spacing);\r\n            if (match) {\r\n                var badCharacter = match[0];\r\n                throw new Error(\"The \\\"\" + parameterName + \"\\\" value contains a non-whitespace character \\\"\" + badCharacter + \"\\\"\");\r\n            }\r\n        }\r\n    };\r\n    /** @virtual */\r\n    DocNode.prototype.updateParameters = function (parameters) {\r\n        // (virtual)\r\n    };\r\n    /**\r\n     * Returns the list of child nodes for this node.  This is useful for visitors that want\r\n     * to scan the tree looking for nodes of a specific type, without having to process\r\n     * intermediary nodes.\r\n     * @virtual\r\n     */\r\n    DocNode.prototype.getChildNodes = function () {\r\n        return [];\r\n    };\r\n    DocNode._badSpacingRegExp = /\\S/;\r\n    return DocNode;\r\n}());\r\nexports.DocNode = DocNode;\r\n//# sourceMappingURL=DocNode.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\n/**\r\n * DocNodeContainer is the base class for DocNode classes that act as a simple container\r\n * for other child nodes.  The child classes are {@link DocParagraph} and {@link DocSection}.\r\n */\r\nvar DocNodeContainer = /** @class */ (function (_super) {\r\n    __extends(DocNodeContainer, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocNodeContainer(parameters) {\r\n        return _super.call(this, parameters) || this;\r\n    }\r\n    Object.defineProperty(DocNodeContainer.prototype, \"nodes\", {\r\n        /**\r\n         * The child nodes.  Note that for subclasses {@link getChildNodes()} may enumerate\r\n         * additional nodes that are not part of this collection.\r\n         */\r\n        get: function () {\r\n            return this._nodes;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocNodeContainer.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        if (this._nodes === undefined) {\r\n            this._nodes = [];\r\n        }\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocNodeContainer.prototype.getChildNodes = function () {\r\n        return this._nodes;\r\n    };\r\n    /**\r\n     * Returns true if the specified `docNode` is allowed to be added as a child node.\r\n     * The {@link appendNode()} and {@link appendNodes()} functions use this to validate their\r\n     * inputs.\r\n     *\r\n     * @virtual\r\n     */\r\n    DocNodeContainer.prototype.isAllowedChildNode = function (docNode) {\r\n        return false;\r\n    };\r\n    /**\r\n     * Append a node to the collection.\r\n     */\r\n    DocNodeContainer.prototype.appendNode = function (docNode) {\r\n        if (!this.isAllowedChildNode(docNode)) {\r\n            throw new Error(\"A \" + this.kind + \" cannot contain nodes of type \" + docNode.kind);\r\n        }\r\n        this._nodes.push(docNode);\r\n    };\r\n    /**\r\n     * Append nodes to the collection.\r\n     */\r\n    DocNodeContainer.prototype.appendNodes = function (docNodes) {\r\n        for (var _i = 0, docNodes_1 = docNodes; _i < docNodes_1.length; _i++) {\r\n            var docNode = docNodes_1[_i];\r\n            this.appendNode(docNode);\r\n        }\r\n    };\r\n    /**\r\n     * Remove all nodes from the collection.\r\n     */\r\n    DocNodeContainer.prototype.clearNodes = function () {\r\n        this._nodes.length = 0;\r\n    };\r\n    return DocNodeContainer;\r\n}(DocNode_1.DocNode));\r\nexports.DocNodeContainer = DocNodeContainer;\r\n//# sourceMappingURL=DocNodeContainer.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\n/**\r\n * Abstract base class for `DocNode` subclasses that correspond to input text,\r\n * i.e. can have an associated Excerpt object.\r\n */\r\nvar DocNodeLeaf = /** @class */ (function (_super) {\r\n    __extends(DocNodeLeaf, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocNodeLeaf(parameters) {\r\n        return _super.call(this, parameters) || this;\r\n    }\r\n    Object.defineProperty(DocNodeLeaf.prototype, \"excerpt\", {\r\n        /**\r\n         * If this DocNode was created by parsing an input, the `DocNode.excerpt`\r\n         * property can be used to track the associated input text.  This can be useful\r\n         * for highlighting matches during refactoring or highlighting error locations.\r\n         */\r\n        get: function () {\r\n            return this._excerpt;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocNodeLeaf.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._excerpt = parameters.excerpt;\r\n    };\r\n    /**\r\n     * Allows the DocNodeLeaf.excerpt to be updated after the object was constructed.\r\n     */\r\n    DocNodeLeaf.prototype.updateExcerpt = function (excerpt) {\r\n        this._excerpt = excerpt;\r\n    };\r\n    return DocNodeLeaf;\r\n}(DocNode_1.DocNode));\r\nexports.DocNodeLeaf = DocNodeLeaf;\r\n//# sourceMappingURL=DocNodeLeaf.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeContainer_1 = require(\"./DocNodeContainer\");\r\n/**\r\n * Represents a paragraph of text, similar to a `<p>` element in HTML.\r\n * Like CommonMark, the TSDoc syntax uses blank lines to delineate paragraphs\r\n * instead of explicitly notating them.\r\n */\r\nvar DocParagraph = /** @class */ (function (_super) {\r\n    __extends(DocParagraph, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocParagraph(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"Paragraph\" /* Paragraph */;\r\n        return _this;\r\n    }\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocParagraph.prototype.isAllowedChildNode = function (docNode) {\r\n        // NOTE: DocNodeKind.Paragraph cannot be nested\r\n        switch (docNode.kind) {\r\n            case \"BlockTag\" /* BlockTag */:\r\n            case \"CodeSpan\" /* CodeSpan */:\r\n            case \"ErrorText\" /* ErrorText */:\r\n            case \"EscapedText\" /* EscapedText */:\r\n            case \"HtmlStartTag\" /* HtmlStartTag */:\r\n            case \"HtmlEndTag\" /* HtmlEndTag */:\r\n            case \"InlineTag\" /* InlineTag */:\r\n            case \"LinkTag\" /* LinkTag */:\r\n            case \"PlainText\" /* PlainText */:\r\n            case \"SoftBreak\" /* SoftBreak */:\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    return DocParagraph;\r\n}(DocNodeContainer_1.DocNodeContainer));\r\nexports.DocParagraph = DocParagraph;\r\n//# sourceMappingURL=DocParagraph.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocBlock_1 = require(\"./DocBlock\");\r\nvar DocParticle_1 = require(\"./DocParticle\");\r\n/**\r\n * Represents a parsed `@param` or `@typeParam` block, which provides a description for a\r\n * function parameter.\r\n */\r\nvar DocParamBlock = /** @class */ (function (_super) {\r\n    __extends(DocParamBlock, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocParamBlock(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"ParamBlock\" /* ParamBlock */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocParamBlock.prototype, \"parameterName\", {\r\n        /**\r\n         * The name of the parameter that is being documented.\r\n         * For example \"width\" in `@param width - the width of the object`.\r\n         */\r\n        get: function () {\r\n            return this._parameterNameParticle.content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocParamBlock.prototype.updateParameters = function (parameters) {\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._parameterNameParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'parameterName',\r\n            excerpt: parameters.parameterNameExcerpt,\r\n            content: parameters.parameterName\r\n        });\r\n        this._hyphenParticle = new DocParticle_1.DocParticle({\r\n            particleId: 'hyphen',\r\n            excerpt: parameters.hyphenExcerpt,\r\n            content: '-'\r\n        });\r\n    };\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocParamBlock.prototype.getChildNodes = function () {\r\n        return [\r\n            this.blockTag,\r\n            this._parameterNameParticle,\r\n            this._hyphenParticle\r\n        ].concat(this.nodes);\r\n    };\r\n    return DocParamBlock;\r\n}(DocBlock_1.DocBlock));\r\nexports.DocParamBlock = DocParamBlock;\r\n//# sourceMappingURL=DocParamBlock.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNode_1 = require(\"./DocNode\");\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\n/**\r\n * DocParticle is used to represent additional generic nodes that are part of the\r\n * DocNode tree, for the purpose of providing additional Excerpt information.\r\n *\r\n * @remarks\r\n * For example, a DocHtmlAttribute has a \"=\" delimiter and a quoted text string\r\n * that may be interesting to highlight in an editor; however, it would be awkward\r\n * to expect developers to construct these nodes as part of constructing a\r\n * DocHtmlAttribute object.  Instead, the developer merely assigns\r\n * DocHtmlAttribute.attributeValue, and the particle nodes automatically appear\r\n * in the tree as a byproduct.  And rather than introducing lots of special-purpose\r\n * types (e.g. DocHtmlAttributeEqualsDelimiter or DocHtmlAttributeStringValue),\r\n * they are represented as generic \"DocParticle\" nodes.\r\n */\r\nvar DocParticle = /** @class */ (function (_super) {\r\n    __extends(DocParticle, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocParticle(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"Particle\" /* Particle */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocParticle.prototype, \"particleId\", {\r\n        /**\r\n         * A string identifier that uniquely identifies a particle among its siblings.\r\n         * This can be used by DocNode.getChildren() visitors to determine what the particle\r\n         * represents.\r\n         */\r\n        get: function () {\r\n            return this._particleId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocParticle.prototype, \"content\", {\r\n        /**\r\n         * The text representation of this particle, excluding any surrounding whitespace.\r\n         */\r\n        get: function () {\r\n            return this._content;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocParticle.prototype, \"spacingAfterContent\", {\r\n        /**\r\n         * Optional explicit whitespace that appears after the main content.\r\n         * If undefined, then the renderer can use a formatting rule to generate appropriate spacing.\r\n         */\r\n        get: function () {\r\n            return this._spacingAfterContent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocParticle.prototype.updateParameters = function (parameters) {\r\n        DocNode_1.DocNode.validateSpacing(parameters.spacingAfterContent, 'spacingAfterContent');\r\n        if (this._particleId && parameters.particleId !== this._particleId) {\r\n            throw new Error('The particleId cannot be changed using updateParameters()');\r\n        }\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._particleId = parameters.particleId;\r\n        this._content = parameters.content;\r\n        this._spacingAfterContent = parameters.spacingAfterContent;\r\n    };\r\n    return DocParticle;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocParticle = DocParticle;\r\n//# sourceMappingURL=DocParticle.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\n/**\r\n * Represents a span of comment text that is considered by the parser\r\n * to contain no special symbols or meaning.\r\n *\r\n * @remarks\r\n * The text content must not contain newline characters.\r\n * Use DocSoftBreak to represent manual line splitting.\r\n */\r\nvar DocPlainText = /** @class */ (function (_super) {\r\n    __extends(DocPlainText, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocPlainText(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"PlainText\" /* PlainText */;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocPlainText.prototype, \"text\", {\r\n        /**\r\n         * The text content.\r\n         */\r\n        get: function () {\r\n            return this._text;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @override */\r\n    DocPlainText.prototype.updateParameters = function (parameters) {\r\n        if (DocPlainText._newlineCharacterRegExp.test(parameters.text)) {\r\n            // Use DocSoftBreak to represent manual line splitting\r\n            throw new Error('The DocPlainText content must not contain newline characters');\r\n        }\r\n        _super.prototype.updateParameters.call(this, parameters);\r\n        this._text = parameters.text;\r\n    };\r\n    // TODO: We should also prohibit \"\\r\", but this requires updating LineExtractor\r\n    // to interpret a lone \"\\r\" as a newline\r\n    DocPlainText._newlineCharacterRegExp = /[\\n]/;\r\n    return DocPlainText;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocPlainText = DocPlainText;\r\n//# sourceMappingURL=DocPlainText.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocParagraph_1 = require(\"./DocParagraph\");\r\nvar DocNodeContainer_1 = require(\"./DocNodeContainer\");\r\n/**\r\n * Represents a general block of rich text.  DocSection is the base class for DocNode classes that\r\n * act as a simple container for other child nodes.\r\n */\r\nvar DocSection = /** @class */ (function (_super) {\r\n    __extends(DocSection, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocSection(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"Section\" /* Section */;\r\n        return _this;\r\n    }\r\n    /**\r\n     * {@inheritDoc}\r\n     * @override\r\n     */\r\n    DocSection.prototype.isAllowedChildNode = function (docNode) {\r\n        switch (docNode.kind) {\r\n            case \"FencedCode\" /* FencedCode */:\r\n            case \"ErrorText\" /* ErrorText */:\r\n            case \"Paragraph\" /* Paragraph */:\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * If the last item in DocSection.nodes is not a DocParagraph, a new paragraph\r\n     * is started.  Either way, the provided docNode will be appended to the paragraph.\r\n     */\r\n    DocSection.prototype.appendNodeInParagraph = function (docNode) {\r\n        var paragraphNode = undefined;\r\n        if (this.nodes.length > 0) {\r\n            var lastNode = this.nodes[this.nodes.length - 1];\r\n            if (lastNode.kind === \"Paragraph\" /* Paragraph */) {\r\n                paragraphNode = lastNode;\r\n            }\r\n        }\r\n        if (!paragraphNode) {\r\n            paragraphNode = new DocParagraph_1.DocParagraph({});\r\n            this.appendNode(paragraphNode);\r\n        }\r\n        paragraphNode.appendNode(docNode);\r\n    };\r\n    return DocSection;\r\n}(DocNodeContainer_1.DocNodeContainer));\r\nexports.DocSection = DocSection;\r\n//# sourceMappingURL=DocSection.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DocNodeLeaf_1 = require(\"./DocNodeLeaf\");\r\n/**\r\n * Instructs a renderer to insert an explicit newline in the output.\r\n * (Normally the renderer uses a formatting rule to determine where\r\n * lines should wrap.)\r\n *\r\n * @remarks\r\n * In HTML, a soft break is represented as an ASCII newline character (which does not\r\n * affect the web browser's view), whereas the hard break is the `<br />` element\r\n * (which starts a new line in the web browser's view).\r\n *\r\n * TSDoc follows the same conventions, except the renderer avoids emitting\r\n * two empty lines (because that could start a new CommonMark paragraph).\r\n */\r\nvar DocSoftBreak = /** @class */ (function (_super) {\r\n    __extends(DocSoftBreak, _super);\r\n    /**\r\n     * Don't call this directly.  Instead use {@link TSDocParser}\r\n     * @internal\r\n     */\r\n    function DocSoftBreak(parameters) {\r\n        var _this = _super.call(this, parameters) || this;\r\n        /** {@inheritDoc} */\r\n        _this.kind = \"SoftBreak\" /* SoftBreak */;\r\n        return _this;\r\n    }\r\n    return DocSoftBreak;\r\n}(DocNodeLeaf_1.DocNodeLeaf));\r\nexports.DocSoftBreak = DocSoftBreak;\r\n//# sourceMappingURL=DocSoftBreak.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./DocBlock\"));\r\n__export(require(\"./DocBlockTag\"));\r\n__export(require(\"./DocFencedCode\"));\r\n__export(require(\"./DocCodeSpan\"));\r\n__export(require(\"./DocComment\"));\r\n__export(require(\"./DocDeclarationReference\"));\r\n__export(require(\"./DocErrorText\"));\r\n__export(require(\"./DocEscapedText\"));\r\n__export(require(\"./DocHtmlAttribute\"));\r\n__export(require(\"./DocHtmlEndTag\"));\r\n__export(require(\"./DocHtmlStartTag\"));\r\n__export(require(\"./DocInlineTag\"));\r\n__export(require(\"./DocInheritDocTag\"));\r\n__export(require(\"./DocLinkTag\"));\r\n__export(require(\"./DocMemberIdentifier\"));\r\n__export(require(\"./DocMemberReference\"));\r\n__export(require(\"./DocMemberSelector\"));\r\n__export(require(\"./DocMemberSymbol\"));\r\n__export(require(\"./DocNode\"));\r\n__export(require(\"./DocNodeContainer\"));\r\n__export(require(\"./DocNodeLeaf\"));\r\n__export(require(\"./DocParagraph\"));\r\n__export(require(\"./DocParamBlock\"));\r\n__export(require(\"./DocParticle\"));\r\n__export(require(\"./DocPlainText\"));\r\n__export(require(\"./DocSection\"));\r\n__export(require(\"./DocSoftBreak\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TokenSequence_1 = require(\"./TokenSequence\");\r\n/**\r\n * When a DocNode is constructed by parsing input text, the Excerpt object is used to\r\n * annotate each node with the associated tokens that were parsed.  This is useful\r\n * e.g. for highlighting the corresponding input characters to indicate a refactoring\r\n * match or error location.\r\n *\r\n * @remarks\r\n * The excerpt is separated into two token sequences: The \"content\" sequence is\r\n * the main textual content for the node.  The \"spacingAfterContent\" optionally captures\r\n * following whitespace, in cases where that whitespace is not interesting.\r\n * (For example, it is not used with DocPlainText since spacing is part of the normal\r\n * plain text content.)\r\n */\r\nvar Excerpt = /** @class */ (function () {\r\n    function Excerpt(parameters) {\r\n        this.parserContext = parameters.content.parserContext;\r\n        this.content = parameters.content;\r\n        this.spacingAfterContent = parameters.spacingAfterContent || TokenSequence_1.TokenSequence.createEmpty(this.parserContext);\r\n    }\r\n    return Excerpt;\r\n}());\r\nexports.Excerpt = Excerpt;\r\n//# sourceMappingURL=Excerpt.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Internal parser state\r\nvar State;\r\n(function (State) {\r\n    // Initial state, looking for \"/*\"\r\n    State[State[\"BeginComment1\"] = 0] = \"BeginComment1\";\r\n    // Looking for \"*\" or \"* \" after \"/*\"\r\n    State[State[\"BeginComment2\"] = 1] = \"BeginComment2\";\r\n    // Like State.CollectingLine except immediately after the \"/**\"\r\n    State[State[\"CollectingFirstLine\"] = 2] = \"CollectingFirstLine\";\r\n    // Collecting characters until we reach a newline\r\n    State[State[\"CollectingLine\"] = 3] = \"CollectingLine\";\r\n    // After a newline, looking for the \"*\" that begins a new line, or the \"*/\" to end the comment\r\n    State[State[\"AdvancingLine\"] = 4] = \"AdvancingLine\";\r\n    // Exiting the parser loop\r\n    State[State[\"Done\"] = 5] = \"Done\";\r\n})(State || (State = {}));\r\n/**\r\n * The main API for parsing TSDoc comments.\r\n */\r\nvar LineExtractor = /** @class */ (function () {\r\n    function LineExtractor() {\r\n    }\r\n    /**\r\n     * This step parses an entire code comment from slash-star-star until star-slash,\r\n     * and extracts the content lines.  The lines are stored in IDocCommentParameters.lines\r\n     * and the overall text range is assigned to IDocCommentParameters.range.\r\n     */\r\n    LineExtractor.extract = function (parserContext) {\r\n        var range = parserContext.sourceRange;\r\n        var buffer = range.buffer;\r\n        var commentRangeStart = 0;\r\n        var commentRangeEnd = 0;\r\n        // These must be set before entering CollectingFirstLine, CollectingLine, or AdvancingLine\r\n        var collectingLineStart = 0;\r\n        var collectingLineEnd = 0;\r\n        var nextIndex = range.pos;\r\n        var state = State.BeginComment1;\r\n        var lines = [];\r\n        while (state !== State.Done) {\r\n            if (nextIndex >= range.end) {\r\n                // reached the end of the input\r\n                switch (state) {\r\n                    case State.BeginComment1:\r\n                    case State.BeginComment2:\r\n                        parserContext.log.addMessageForTextRange('Expecting a \"/**\" comment', range);\r\n                        return false;\r\n                    default:\r\n                        parserContext.log.addMessageForTextRange('Unexpected end of input', range);\r\n                        return false;\r\n                }\r\n            }\r\n            var current = buffer[nextIndex];\r\n            var currentIndex = nextIndex;\r\n            ++nextIndex;\r\n            var next = nextIndex < range.end ? buffer[nextIndex] : '';\r\n            switch (state) {\r\n                case State.BeginComment1:\r\n                    if (current === '/' && next === '*') {\r\n                        commentRangeStart = currentIndex;\r\n                        ++nextIndex; // skip the star\r\n                        state = State.BeginComment2;\r\n                    }\r\n                    else if (!LineExtractor._whitespaceCharacterRegExp.test(current)) {\r\n                        parserContext.log.addMessageForTextRange('Expecting a leading \"/**\"', range.getNewRange(currentIndex, currentIndex + 1));\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case State.BeginComment2:\r\n                    if (current === '*') {\r\n                        if (next === ' ') {\r\n                            ++nextIndex; // Discard the space after the star\r\n                        }\r\n                        collectingLineStart = nextIndex;\r\n                        collectingLineEnd = nextIndex;\r\n                        state = State.CollectingFirstLine;\r\n                    }\r\n                    else {\r\n                        parserContext.log.addMessageForTextRange('Expecting a leading \"/**\"', range.getNewRange(currentIndex, currentIndex + 1));\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case State.CollectingFirstLine:\r\n                case State.CollectingLine:\r\n                    if (current === '\\n') {\r\n                        // Ignore an empty line if it is immediately after the \"/**\"\r\n                        if (state !== State.CollectingFirstLine || collectingLineEnd > collectingLineStart) {\r\n                            // Record the line that we collected\r\n                            lines.push(range.getNewRange(collectingLineStart, collectingLineEnd));\r\n                        }\r\n                        collectingLineStart = nextIndex;\r\n                        collectingLineEnd = nextIndex;\r\n                        state = State.AdvancingLine;\r\n                    }\r\n                    else if (current === '*' && next === '/') {\r\n                        if (collectingLineEnd > collectingLineStart) {\r\n                            lines.push(range.getNewRange(collectingLineStart, collectingLineEnd));\r\n                        }\r\n                        collectingLineStart = 0;\r\n                        collectingLineEnd = 0;\r\n                        ++nextIndex; // skip the slash\r\n                        commentRangeEnd = nextIndex;\r\n                        state = State.Done;\r\n                    }\r\n                    else if (!LineExtractor._whitespaceCharacterRegExp.test(current)) {\r\n                        collectingLineEnd = nextIndex;\r\n                    }\r\n                    break;\r\n                case State.AdvancingLine:\r\n                    if (current === '*') {\r\n                        if (next === '/') {\r\n                            collectingLineStart = 0;\r\n                            collectingLineEnd = 0;\r\n                            ++nextIndex; // skip the slash\r\n                            commentRangeEnd = nextIndex;\r\n                            state = State.Done;\r\n                        }\r\n                        else {\r\n                            // Discard the \"*\" at the start of a line\r\n                            if (next === ' ') {\r\n                                ++nextIndex; // Discard the space after the star\r\n                            }\r\n                            collectingLineStart = nextIndex;\r\n                            collectingLineEnd = nextIndex;\r\n                            state = State.CollectingLine;\r\n                        }\r\n                    }\r\n                    else if (current === '\\n') {\r\n                        // Blank line\r\n                        lines.push(range.getNewRange(currentIndex, currentIndex));\r\n                        collectingLineStart = nextIndex;\r\n                    }\r\n                    else if (!LineExtractor._whitespaceCharacterRegExp.test(current)) {\r\n                        // If the star is missing, then start the line here\r\n                        // Example: \"/**\\nL1*/\"\r\n                        // (collectingLineStart was the start of this line)\r\n                        collectingLineEnd = currentIndex;\r\n                        state = State.CollectingLine;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        /**\r\n         * Only fill in these if we successfully scanned a comment\r\n         */\r\n        parserContext.commentRange = range.getNewRange(commentRangeStart, commentRangeEnd);\r\n        parserContext.lines = lines;\r\n        return true;\r\n    };\r\n    LineExtractor._whitespaceCharacterRegExp = /^\\s$/;\r\n    return LineExtractor;\r\n}());\r\nexports.LineExtractor = LineExtractor;\r\n//# sourceMappingURL=LineExtractor.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Token_1 = require(\"./Token\");\r\nvar Tokenizer_1 = require(\"./Tokenizer\");\r\nvar nodes_1 = require(\"../nodes\");\r\nvar TokenSequence_1 = require(\"./TokenSequence\");\r\nvar Excerpt_1 = require(\"./Excerpt\");\r\nvar TokenReader_1 = require(\"./TokenReader\");\r\nvar StringChecks_1 = require(\"./StringChecks\");\r\nvar TSDocTagDefinition_1 = require(\"./TSDocTagDefinition\");\r\nvar StandardTags_1 = require(\"../details/StandardTags\");\r\nvar PlainTextRenderer_1 = require(\"../renderers/PlainTextRenderer\");\r\nfunction isFailure(resultOrFailure) {\r\n    return resultOrFailure !== undefined && resultOrFailure.hasOwnProperty('failureMessage');\r\n}\r\n/**\r\n * The main parser for TSDoc comments.\r\n */\r\nvar NodeParser = /** @class */ (function () {\r\n    function NodeParser(parserContext) {\r\n        this._parserContext = parserContext;\r\n        this._currentSection = parserContext.docComment.summarySection;\r\n    }\r\n    NodeParser.prototype.parse = function () {\r\n        var tokenReader = new TokenReader_1.TokenReader(this._parserContext);\r\n        var done = false;\r\n        while (!done) {\r\n            // Extract the next token\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.EndOfInput:\r\n                    done = true;\r\n                    break;\r\n                case Token_1.TokenKind.Newline:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    tokenReader.readToken();\r\n                    this._pushParagraphNode(new nodes_1.DocSoftBreak({\r\n                        excerpt: new Excerpt_1.Excerpt({ content: tokenReader.extractAccumulatedSequence() })\r\n                    }));\r\n                    break;\r\n                case Token_1.TokenKind.Backslash:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    this._pushParagraphNode(this._parseBackslashEscape(tokenReader));\r\n                    break;\r\n                case Token_1.TokenKind.AtSign:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    this._parseAndPushBlock(tokenReader);\r\n                    break;\r\n                case Token_1.TokenKind.LeftCurlyBracket: {\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    var marker = tokenReader.createMarker();\r\n                    var docNode = this._parseInlineTag(tokenReader);\r\n                    var docComment = this._parserContext.docComment;\r\n                    if (docNode instanceof nodes_1.DocInheritDocTag) {\r\n                        // The @inheritDoc tag is irregular because it looks like an inline tag, but\r\n                        // it actually represents the entire comment body\r\n                        var tagEndMarker = tokenReader.createMarker() - 1;\r\n                        if (docComment.inheritDocTag === undefined) {\r\n                            this._parserContext.docComment.inheritDocTag = docNode;\r\n                        }\r\n                        else {\r\n                            this._pushParagraphNode(this._backtrackAndCreateErrorRange(tokenReader, marker, tagEndMarker, 'A doc comment cannot have more than one @inheritDoc tag'));\r\n                        }\r\n                    }\r\n                    else {\r\n                        this._pushParagraphNode(docNode);\r\n                    }\r\n                    break;\r\n                }\r\n                case Token_1.TokenKind.RightCurlyBracket:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    this._pushParagraphNode(this._createError(tokenReader, 'The \"}\" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag'));\r\n                    break;\r\n                case Token_1.TokenKind.LessThan:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    // Look ahead two tokens to see if this is \"<a>\" or \"</a>\".\r\n                    if (tokenReader.peekTokenAfterKind() === Token_1.TokenKind.Slash) {\r\n                        this._pushParagraphNode(this._parseHtmlEndTag(tokenReader));\r\n                    }\r\n                    else {\r\n                        this._pushParagraphNode(this._parseHtmlStartTag(tokenReader));\r\n                    }\r\n                    break;\r\n                case Token_1.TokenKind.GreaterThan:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    this._pushParagraphNode(this._createError(tokenReader, 'The \">\" character should be escaped using a backslash to avoid confusion with an HTML tag'));\r\n                    break;\r\n                case Token_1.TokenKind.Backtick:\r\n                    this._pushAccumulatedPlainText(tokenReader);\r\n                    if (tokenReader.peekTokenAfterKind() === Token_1.TokenKind.Backtick\r\n                        && tokenReader.peekTokenAfterAfterKind() === Token_1.TokenKind.Backtick) {\r\n                        this._pushSectionNode(this._parseFencedCode(tokenReader));\r\n                    }\r\n                    else {\r\n                        this._pushParagraphNode(this._parseCodeSpan(tokenReader));\r\n                    }\r\n                    break;\r\n                default:\r\n                    // If nobody recognized this token, then accumulate plain text\r\n                    tokenReader.readToken();\r\n                    break;\r\n            }\r\n        }\r\n        this._pushAccumulatedPlainText(tokenReader);\r\n        this._performValidationChecks();\r\n    };\r\n    NodeParser.prototype._performValidationChecks = function () {\r\n        var docComment = this._parserContext.docComment;\r\n        if (docComment.deprecatedBlock) {\r\n            if (!PlainTextRenderer_1.PlainTextRenderer.hasAnyTextContent(docComment.deprecatedBlock)) {\r\n                this._parserContext.log.addMessageForTokenSequence(\"The \" + docComment.deprecatedBlock.blockTag.tagName + \" block must include a deprecation message,\"\r\n                    + \" e.g. describing the recommended alternative\", docComment.deprecatedBlock.blockTag.excerpt.content, docComment.deprecatedBlock);\r\n            }\r\n        }\r\n        if (docComment.inheritDocTag) {\r\n            if (docComment.remarksBlock) {\r\n                this._parserContext.log.addMessageForTokenSequence(\"A \\\"\" + docComment.remarksBlock.blockTag.tagName + \"\\\" block must not be used, because that\"\r\n                    + \" content is provided by the @inheritDoc tag\", docComment.remarksBlock.blockTag.excerpt.content, docComment.remarksBlock.blockTag);\r\n            }\r\n            if (PlainTextRenderer_1.PlainTextRenderer.hasAnyTextContent(docComment.summarySection)) {\r\n                this._parserContext.log.addMessageForTextRange('The summary section must not have any content, because that'\r\n                    + ' content is provided by the @inheritDoc tag', this._parserContext.commentRange);\r\n            }\r\n        }\r\n    };\r\n    NodeParser.prototype._validateTagDefinition = function (tagDefinition, tagName, expectingInlineTag, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        if (tagDefinition) {\r\n            var isInlineTag = tagDefinition.syntaxKind === TSDocTagDefinition_1.TSDocTagSyntaxKind.InlineTag;\r\n            if (isInlineTag !== expectingInlineTag) {\r\n                // The tag is defined, but it is used incorrectly\r\n                if (expectingInlineTag) {\r\n                    this._parserContext.log.addMessageForTokenSequence(\"The TSDoc tag \\\"\" + tagName + \"\\\" is an inline tag; it must be enclosed in \\\"{ }\\\" braces\", tokenSequenceForErrorContext, nodeForErrorContext);\r\n                }\r\n                else {\r\n                    this._parserContext.log.addMessageForTokenSequence(\"The TSDoc tag \\\"\" + tagName + \"\\\" is not an inline tag; it must not be enclosed in \\\"{ }\\\" braces\", tokenSequenceForErrorContext, nodeForErrorContext);\r\n                }\r\n            }\r\n            else {\r\n                if (this._parserContext.configuration.validation.reportUnsupportedTags) {\r\n                    if (!this._parserContext.configuration.isTagSupported(tagDefinition)) {\r\n                        // The tag is defined, but not supported\r\n                        this._parserContext.log.addMessageForTokenSequence(\"The TSDoc tag \\\"\" + tagName + \"\\\" is not supported by this tool\", tokenSequenceForErrorContext, nodeForErrorContext);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // The tag is not defined\r\n            if (!this._parserContext.configuration.validation.ignoreUndefinedTags) {\r\n                this._parserContext.log.addMessageForTokenSequence(\"The TSDoc tag \\\"\" + tagName + \"\\\" is not defined in this configuration\", tokenSequenceForErrorContext, nodeForErrorContext);\r\n            }\r\n        }\r\n    };\r\n    NodeParser.prototype._pushAccumulatedPlainText = function (tokenReader) {\r\n        if (!tokenReader.isAccumulatedSequenceEmpty()) {\r\n            var plainTextSequence = tokenReader.extractAccumulatedSequence();\r\n            this._pushParagraphNode(new nodes_1.DocPlainText({\r\n                text: plainTextSequence.toString(),\r\n                excerpt: new Excerpt_1.Excerpt({ content: plainTextSequence })\r\n            }));\r\n        }\r\n    };\r\n    NodeParser.prototype._parseAndPushBlock = function (tokenReader) {\r\n        var docComment = this._parserContext.docComment;\r\n        var configuration = this._parserContext.configuration;\r\n        var modifierTagSet = docComment.modifierTagSet;\r\n        var parsedBlockTag = this._parseBlockTag(tokenReader);\r\n        if (parsedBlockTag.kind !== \"BlockTag\" /* BlockTag */) {\r\n            this._pushParagraphNode(parsedBlockTag);\r\n            return;\r\n        }\r\n        var docBlockTag = parsedBlockTag;\r\n        // Do we have a definition for this tag?\r\n        var tagDefinition = configuration.tryGetTagDefinitionWithUpperCase(docBlockTag.tagNameWithUpperCase);\r\n        this._validateTagDefinition(tagDefinition, docBlockTag.tagName, /* expectingInlineTag */ false, docBlockTag.excerpt.content, docBlockTag);\r\n        if (tagDefinition) {\r\n            switch (tagDefinition.syntaxKind) {\r\n                case TSDocTagDefinition_1.TSDocTagSyntaxKind.BlockTag:\r\n                    if (docBlockTag.tagNameWithUpperCase === StandardTags_1.StandardTags.param.tagNameWithUpperCase) {\r\n                        var docParamBlock = this._parseParamBlock(tokenReader, docBlockTag);\r\n                        this._parserContext.docComment.paramBlocks.push(docParamBlock);\r\n                        this._currentSection = docParamBlock;\r\n                        return;\r\n                    }\r\n                    else if (docBlockTag.tagNameWithUpperCase === StandardTags_1.StandardTags.typeParam.tagNameWithUpperCase) {\r\n                        var docParamBlock = this._parseParamBlock(tokenReader, docBlockTag);\r\n                        this._parserContext.docComment.typeParamBlocks.push(docParamBlock);\r\n                        this._currentSection = docParamBlock;\r\n                        return;\r\n                    }\r\n                    else {\r\n                        var newBlock = new nodes_1.DocBlock({\r\n                            blockTag: docBlockTag\r\n                        });\r\n                        this._addBlockToDocComment(newBlock);\r\n                        this._currentSection = newBlock;\r\n                    }\r\n                    return;\r\n                case TSDocTagDefinition_1.TSDocTagSyntaxKind.ModifierTag:\r\n                    // The block tag was recognized as a modifier, so add it to the modifier tag set\r\n                    // and do NOT call currentSection.appendNode(parsedNode)\r\n                    modifierTagSet.addTag(docBlockTag);\r\n                    return;\r\n            }\r\n        }\r\n        this._pushParagraphNode(docBlockTag);\r\n    };\r\n    NodeParser.prototype._addBlockToDocComment = function (block) {\r\n        var docComment = this._parserContext.docComment;\r\n        switch (block.blockTag.tagNameWithUpperCase) {\r\n            case StandardTags_1.StandardTags.remarks.tagNameWithUpperCase:\r\n                docComment.remarksBlock = block;\r\n                break;\r\n            case StandardTags_1.StandardTags.privateRemarks.tagNameWithUpperCase:\r\n                docComment.privateRemarks = block;\r\n                break;\r\n            case StandardTags_1.StandardTags.deprecated.tagNameWithUpperCase:\r\n                docComment.deprecatedBlock = block;\r\n                break;\r\n            case StandardTags_1.StandardTags.returns.tagNameWithUpperCase:\r\n                docComment.returnsBlock = block;\r\n                break;\r\n            default:\r\n                docComment.appendCustomBlock(block);\r\n        }\r\n    };\r\n    NodeParser.prototype._parseParamBlock = function (tokenReader, docBlockTag) {\r\n        var startMarker = tokenReader.createMarker();\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        var leadingWhitespaceSequence = tokenReader.tryExtractAccumulatedSequence();\r\n        var parameterName = '';\r\n        var done = false;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.AsciiWord:\r\n                case Token_1.TokenKind.Period:\r\n                    parameterName += tokenReader.readToken();\r\n                    break;\r\n                default:\r\n                    done = true;\r\n                    break;\r\n            }\r\n        }\r\n        if (parameterName.length === 0) {\r\n            tokenReader.backtrackToMarker(startMarker);\r\n            var errorParamBlock = new nodes_1.DocParamBlock({\r\n                blockTag: docBlockTag,\r\n                parameterName: ''\r\n            });\r\n            this._parserContext.log.addMessageForTokenSequence('The @param block should be followed by a parameter name', docBlockTag.excerpt.content, docBlockTag);\r\n            return errorParamBlock;\r\n        }\r\n        var parameterNameExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        // TODO: Warn if there is no space before or after the hyphen\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        parameterNameExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Hyphen) {\r\n            tokenReader.backtrackToMarker(startMarker);\r\n            this._parserContext.log.addMessageForTokenSequence('The @param block should be followed by a parameter name and then a hyphen', docBlockTag.excerpt.content, docBlockTag);\r\n            return new nodes_1.DocParamBlock({\r\n                blockTag: docBlockTag,\r\n                parameterName: ''\r\n            });\r\n        }\r\n        tokenReader.readToken();\r\n        var hyphenExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        // TODO: Only read one space\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        hyphenExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        if (leadingWhitespaceSequence) {\r\n            // The leading whitespace that we parsed to the docBlockTag\r\n            docBlockTag.updateExcerpt(new Excerpt_1.Excerpt({\r\n                content: docBlockTag.excerpt.content,\r\n                spacingAfterContent: leadingWhitespaceSequence\r\n            }));\r\n        }\r\n        return new nodes_1.DocParamBlock({\r\n            blockTag: docBlockTag,\r\n            parameterNameExcerpt: new Excerpt_1.Excerpt(parameterNameExcerptParameters),\r\n            parameterName: parameterName,\r\n            hyphenExcerpt: new Excerpt_1.Excerpt(hyphenExcerptParameters)\r\n        });\r\n    };\r\n    NodeParser.prototype._pushParagraphNode = function (docNode) {\r\n        this._currentSection.appendNodeInParagraph(docNode);\r\n    };\r\n    NodeParser.prototype._pushSectionNode = function (docNode) {\r\n        this._currentSection.appendNode(docNode);\r\n    };\r\n    NodeParser.prototype._parseBackslashEscape = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var marker = tokenReader.createMarker();\r\n        tokenReader.readToken();\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.EndOfInput) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'A backslash must precede another character that is being escaped');\r\n        }\r\n        var escapedToken = tokenReader.readToken();\r\n        // In CommonMark, a backslash is only allowed before a punctuation\r\n        // character.  In all other contexts, the backslash is interpreted as a\r\n        // literal character.\r\n        if (!Tokenizer_1.Tokenizer.isPunctuation(escapedToken.kind)) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'A backslash can only be used to escape a punctuation character');\r\n        }\r\n        var tokenSequence = tokenReader.extractAccumulatedSequence();\r\n        return new nodes_1.DocEscapedText({\r\n            excerpt: new Excerpt_1.Excerpt({ content: tokenSequence }),\r\n            escapeStyle: nodes_1.EscapeStyle.CommonMarkBackslash,\r\n            text: escapedToken.toString()\r\n        });\r\n    };\r\n    NodeParser.prototype._parseBlockTag = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var marker = tokenReader.createMarker();\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.AtSign) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting a TSDoc tag starting with \"@\"');\r\n        }\r\n        // \"@one\" is a valid TSDoc tag at the start of a line, but \"@one@two\" is\r\n        // a syntax error.  For two tags it should be \"@one @two\", or for literal text it\r\n        // should be \"\\@one\\@two\".\r\n        switch (tokenReader.peekPreviousTokenKind()) {\r\n            case Token_1.TokenKind.EndOfInput:\r\n            case Token_1.TokenKind.Spacing:\r\n            case Token_1.TokenKind.Newline:\r\n                break;\r\n            default:\r\n                return this._backtrackAndCreateError(tokenReader, marker, 'A TSDoc tag must be preceded by whitespace');\r\n        }\r\n        // Include the \"@\" as part of the tagName\r\n        var tagName = tokenReader.readToken().toString();\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.AsciiWord) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting a TSDoc tag name after the \"@\" character (or use a backslash to escape this character)');\r\n        }\r\n        var tagNameMarker = tokenReader.createMarker();\r\n        while (tokenReader.peekTokenKind() === Token_1.TokenKind.AsciiWord) {\r\n            tagName += tokenReader.readToken().toString();\r\n        }\r\n        if (tagName.length === 0) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting an inline TSDoc tag name immediately after \"{@\"');\r\n        }\r\n        if (StringChecks_1.StringChecks.explainIfInvalidTSDocTagName(tagName)) {\r\n            var failure = this._createFailureForTokensSince(tokenReader, 'A TSDoc tag name must start with a letter and contain only letters and numbers', tagNameMarker);\r\n            return this._backtrackAndCreateErrorForFailure(tokenReader, marker, '', failure);\r\n        }\r\n        switch (tokenReader.peekTokenKind()) {\r\n            case Token_1.TokenKind.Spacing:\r\n            case Token_1.TokenKind.Newline:\r\n            case Token_1.TokenKind.EndOfInput:\r\n                break;\r\n            default:\r\n                return this._backtrackAndCreateError(tokenReader, marker, 'A TSDoc tag must be followed by whitespace');\r\n        }\r\n        return new nodes_1.DocBlockTag({\r\n            excerpt: new Excerpt_1.Excerpt({ content: tokenReader.extractAccumulatedSequence() }),\r\n            tagName: tagName\r\n        });\r\n    };\r\n    NodeParser.prototype._parseInlineTag = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var marker = tokenReader.createMarker();\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.LeftCurlyBracket) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting a TSDoc tag starting with \"{\"');\r\n        }\r\n        tokenReader.readToken();\r\n        var openingDelimiterExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        // For inline tags, if we handle errors by backtracking to the \"{\"  token, then the main loop\r\n        // will then interpret the \"@\" as a block tag, which is almost certainly incorrect.  So the\r\n        // DocErrorText needs to include both the \"{\" and \"@\" tokens.\r\n        // We will use _backtrackAndCreateErrorRangeForFailure() for that.\r\n        var atSignMarker = tokenReader.createMarker();\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.AtSign) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting a TSDoc tag starting with \"{@\"');\r\n        }\r\n        // Include the \"@\" as part of the tagName\r\n        var tagName = tokenReader.readToken().toString();\r\n        while (tokenReader.peekTokenKind() === Token_1.TokenKind.AsciiWord) {\r\n            tagName += tokenReader.readToken().toString();\r\n        }\r\n        if (tagName === '@') {\r\n            // This is an unusual case\r\n            var failure = this._createFailureForTokensSince(tokenReader, 'Expecting a TSDoc inline tag name after the \"{@\" characters', atSignMarker);\r\n            return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, '', failure);\r\n        }\r\n        if (StringChecks_1.StringChecks.explainIfInvalidTSDocTagName(tagName)) {\r\n            var failure = this._createFailureForTokensSince(tokenReader, 'A TSDoc tag name must start with a letter and contain only letters and numbers', atSignMarker);\r\n            return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, '', failure);\r\n        }\r\n        var tagNameExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        var spacingAfterTagName = this._readSpacingAndNewlines(tokenReader);\r\n        tagNameExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        if (spacingAfterTagName.length === 0) {\r\n            // If there were no spaces at all, that's an error unless it's the degenerate \"{@tag}\" case\r\n            if (tokenReader.peekTokenKind() !== Token_1.TokenKind.RightCurlyBracket) {\r\n                var failure = this._createFailureForToken(tokenReader, 'Expecting a space after the TSDoc inline tag name');\r\n                return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, '', failure);\r\n            }\r\n        }\r\n        var tagContent = '';\r\n        var done = false;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.EndOfInput:\r\n                    return this._backtrackAndCreateErrorRange(tokenReader, marker, atSignMarker, 'The TSDoc inline tag name is missing its closing \"}\"');\r\n                case Token_1.TokenKind.Backslash:\r\n                    // http://usejsdoc.org/about-block-inline-tags.html\r\n                    // \"If your tag's text includes a closing curly brace (}), you must escape it with\r\n                    // a leading backslash (\\).\"\r\n                    tokenReader.readToken(); // discard the backslash\r\n                    // In CommonMark, a backslash is only allowed before a punctuation\r\n                    // character.  In all other contexts, the backslash is interpreted as a\r\n                    // literal character.\r\n                    if (!Tokenizer_1.Tokenizer.isPunctuation(tokenReader.peekTokenKind())) {\r\n                        var failure = this._createFailureForToken(tokenReader, 'A backslash can only be used to escape a punctuation character');\r\n                        return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, 'Error reading inline TSDoc tag: ', failure);\r\n                    }\r\n                    tagContent += tokenReader.readToken().toString();\r\n                    break;\r\n                case Token_1.TokenKind.LeftCurlyBracket:\r\n                    {\r\n                        var failure = this._createFailureForToken(tokenReader, 'The \"{\" character must be escaped with a backslash when used inside a TSDoc inline tag');\r\n                        return this._backtrackAndCreateErrorRangeForFailure(tokenReader, marker, atSignMarker, '', failure);\r\n                    }\r\n                case Token_1.TokenKind.RightCurlyBracket:\r\n                    done = true;\r\n                    break;\r\n                default:\r\n                    tagContent += tokenReader.readToken().toString();\r\n                    break;\r\n            }\r\n        }\r\n        var tagContentExcerpt;\r\n        if (!tokenReader.isAccumulatedSequenceEmpty()) {\r\n            tagContentExcerpt = new Excerpt_1.Excerpt({\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            });\r\n        }\r\n        // Read the right curly bracket\r\n        tokenReader.readToken();\r\n        var closingDelimiterExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        var docInlineTagParameters = {\r\n            openingDelimiterExcerpt: new Excerpt_1.Excerpt(openingDelimiterExcerptParameters),\r\n            tagNameExcerpt: new Excerpt_1.Excerpt(tagNameExcerptParameters),\r\n            tagName: tagName,\r\n            tagContentExcerpt: tagContentExcerpt,\r\n            tagContent: tagContent,\r\n            closingDelimiterExcerpt: new Excerpt_1.Excerpt(closingDelimiterExcerptParameters)\r\n        };\r\n        var tagNameWithUpperCase = tagName.toUpperCase();\r\n        // Create a new TokenReader that will reparse the tokens corresponding to the tagContent.\r\n        var embeddedTokenReader = new TokenReader_1.TokenReader(this._parserContext, tagContentExcerpt ? tagContentExcerpt.content : TokenSequence_1.TokenSequence.createEmpty(this._parserContext));\r\n        var docNode;\r\n        switch (tagNameWithUpperCase) {\r\n            case StandardTags_1.StandardTags.inheritDoc.tagNameWithUpperCase:\r\n                docNode = this._parseInheritDocTag(docInlineTagParameters, embeddedTokenReader);\r\n                break;\r\n            case StandardTags_1.StandardTags.link.tagNameWithUpperCase:\r\n                docNode = this._parseLinkTag(docInlineTagParameters, embeddedTokenReader);\r\n                break;\r\n            default:\r\n                docNode = new nodes_1.DocInlineTag(docInlineTagParameters);\r\n        }\r\n        // Validate the tag\r\n        var tagDefinition = this._parserContext.configuration.tryGetTagDefinitionWithUpperCase(tagNameWithUpperCase);\r\n        this._validateTagDefinition(tagDefinition, tagName, /* expectingInlineTag */ true, tagNameExcerptParameters.content, docNode);\r\n        return docNode;\r\n    };\r\n    NodeParser.prototype._parseInheritDocTag = function (docInlineTagParameters, embeddedTokenReader) {\r\n        var docInheritDocTag = new nodes_1.DocInheritDocTag(docInlineTagParameters);\r\n        var parameters = __assign({}, docInlineTagParameters);\r\n        if (embeddedTokenReader.peekTokenKind() !== Token_1.TokenKind.EndOfInput) {\r\n            parameters.declarationReference = this._parseDeclarationReference(embeddedTokenReader, docInlineTagParameters.tagNameExcerpt.content, docInheritDocTag);\r\n            if (!parameters.declarationReference) {\r\n                return docInheritDocTag; // error\r\n            }\r\n            if (embeddedTokenReader.peekTokenKind() !== Token_1.TokenKind.EndOfInput) {\r\n                embeddedTokenReader.readToken();\r\n                this._parserContext.log.addMessageForTokenSequence('Unexpected character after declaration reference', embeddedTokenReader.extractAccumulatedSequence(), docInheritDocTag);\r\n                return docInheritDocTag; // error\r\n            }\r\n        }\r\n        // We don't need the tagContentExcerpt since those tokens are now associated with the link particles\r\n        parameters.tagContentExcerpt = undefined;\r\n        docInheritDocTag.updateParameters(parameters);\r\n        return docInheritDocTag;\r\n    };\r\n    NodeParser.prototype._parseLinkTag = function (docInlineTagParameters, embeddedTokenReader) {\r\n        var docLinkTag = new nodes_1.DocLinkTag(docInlineTagParameters);\r\n        var parameters = __assign({}, docInlineTagParameters);\r\n        if (!parameters.tagContentExcerpt) {\r\n            this._parserContext.log.addMessageForTokenSequence('The @link tag content is missing', parameters.tagNameExcerpt.content, docLinkTag);\r\n            return docLinkTag; // error\r\n        }\r\n        // Is the link destination a URL or a declaration reference?\r\n        //\r\n        // The JSDoc \"@link\" tag allows URLs, however supporting full URLs would be highly\r\n        // ambiguous, for example \"microsoft.windows.camera:\" is an actual valid URI scheme,\r\n        // and even the common \"mailto:example.com\" looks suspiciously like a declaration reference.\r\n        // In practice JSDoc URLs are nearly always HTTP or HTTPS, so it seems fairly reasonable to\r\n        // require the URL to have \"://\" and a scheme without any punctuation in it.  If a more exotic\r\n        // URL is needed, the HTML \"<a>\" tag can always be used.\r\n        // We start with a fairly broad classifier heuristic, and then the parsers will refine this:\r\n        // 1. Does it start with \"//\"?\r\n        // 2. Does it contain \"://\"?\r\n        var looksLikeUrl = embeddedTokenReader.peekTokenKind() === Token_1.TokenKind.Slash\r\n            && embeddedTokenReader.peekTokenAfterKind() === Token_1.TokenKind.Slash;\r\n        var marker = embeddedTokenReader.createMarker();\r\n        var done = looksLikeUrl;\r\n        while (!done) {\r\n            switch (embeddedTokenReader.peekTokenKind()) {\r\n                // An URI scheme can contain letters, numbers, minus, plus, and periods\r\n                case Token_1.TokenKind.AsciiWord:\r\n                case Token_1.TokenKind.Period:\r\n                case Token_1.TokenKind.Hyphen:\r\n                case Token_1.TokenKind.Plus:\r\n                    embeddedTokenReader.readToken();\r\n                    break;\r\n                case Token_1.TokenKind.Colon:\r\n                    embeddedTokenReader.readToken();\r\n                    // Once we a reach a colon, then it's a URL only if we see \"://\"\r\n                    looksLikeUrl = embeddedTokenReader.peekTokenKind() === Token_1.TokenKind.Slash\r\n                        && embeddedTokenReader.peekTokenAfterKind() === Token_1.TokenKind.Slash;\r\n                    done = true;\r\n                    break;\r\n                default:\r\n                    done = true;\r\n            }\r\n        }\r\n        embeddedTokenReader.backtrackToMarker(marker);\r\n        // Is the hyperlink a URL or a declaration reference?\r\n        if (looksLikeUrl) {\r\n            // It starts with something like \"http://\", so parse it as a URL\r\n            if (!this._parseLinkTagUrlDestination(embeddedTokenReader, parameters, docInlineTagParameters.tagNameExcerpt.content, docLinkTag)) {\r\n                return docLinkTag; // error\r\n            }\r\n        }\r\n        else {\r\n            // Otherwise, assume it's a declaration reference\r\n            if (!this._parseLinkTagCodeDestination(embeddedTokenReader, parameters, docInlineTagParameters.tagNameExcerpt.content, docLinkTag)) {\r\n                return docLinkTag; // error\r\n            }\r\n        }\r\n        if (embeddedTokenReader.peekTokenKind() === Token_1.TokenKind.Spacing) {\r\n            // The above parser rules should have consumed any spacing before the pipe\r\n            throw new Error('Unconsumed spacing encountered after construct');\r\n        }\r\n        if (embeddedTokenReader.peekTokenKind() === Token_1.TokenKind.Pipe) {\r\n            // Read the link text\r\n            embeddedTokenReader.readToken();\r\n            parameters.pipeExcerpt = new Excerpt_1.Excerpt({\r\n                content: embeddedTokenReader.extractAccumulatedSequence()\r\n            });\r\n            // Read everything until the end\r\n            // NOTE: Because we're using an embedded TokenReader, the TokenKind.EndOfInput occurs\r\n            // when we reach the \"}\", not the end of the original input\r\n            done = false;\r\n            while (!done) {\r\n                switch (embeddedTokenReader.peekTokenKind()) {\r\n                    case Token_1.TokenKind.EndOfInput:\r\n                        done = true;\r\n                        break;\r\n                    case Token_1.TokenKind.Pipe:\r\n                    case Token_1.TokenKind.LeftCurlyBracket:\r\n                        var badCharacter = embeddedTokenReader.readToken().toString();\r\n                        this._parserContext.log.addMessageForTokenSequence(\"The \\\"\" + badCharacter + \"\\\" character may not be used in the link text without escaping it\", embeddedTokenReader.extractAccumulatedSequence(), docLinkTag);\r\n                        return docLinkTag; // error\r\n                    default:\r\n                        embeddedTokenReader.readToken();\r\n                }\r\n            }\r\n            if (!embeddedTokenReader.isAccumulatedSequenceEmpty()) {\r\n                var linkTextExcerpt = new Excerpt_1.Excerpt({\r\n                    content: embeddedTokenReader.extractAccumulatedSequence()\r\n                });\r\n                parameters.linkText = linkTextExcerpt.content.toString();\r\n                parameters.linkTextExcerpt = linkTextExcerpt;\r\n            }\r\n        }\r\n        else if (embeddedTokenReader.peekTokenKind() !== Token_1.TokenKind.EndOfInput) {\r\n            embeddedTokenReader.readToken();\r\n            this._parserContext.log.addMessageForTokenSequence('Unexpected character after link destination', embeddedTokenReader.extractAccumulatedSequence(), docLinkTag);\r\n            return docLinkTag; // error\r\n        }\r\n        // We don't need the tagContentExcerpt since those tokens are now associated with the link particles\r\n        parameters.tagContentExcerpt = undefined;\r\n        docLinkTag.updateParameters(parameters);\r\n        return docLinkTag;\r\n    };\r\n    NodeParser.prototype._parseLinkTagUrlDestination = function (embeddedTokenReader, parameters, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        // Simply accumulate everything up to the next space. We won't try to implement a proper\r\n        // URI parser here.\r\n        var url = '';\r\n        var done = false;\r\n        while (!done) {\r\n            switch (embeddedTokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.Spacing:\r\n                case Token_1.TokenKind.Newline:\r\n                case Token_1.TokenKind.EndOfInput:\r\n                case Token_1.TokenKind.Pipe:\r\n                case Token_1.TokenKind.RightCurlyBracket:\r\n                    done = true;\r\n                    break;\r\n                default:\r\n                    url += embeddedTokenReader.readToken();\r\n                    break;\r\n            }\r\n        }\r\n        if (url.length === 0) {\r\n            // This should be impossible since the caller ensures that peekTokenKind() === TokenKind.AsciiWord\r\n            throw new Error('Missing URL in _parseLinkTagUrl()');\r\n        }\r\n        var excerptParameters = {\r\n            content: embeddedTokenReader.extractAccumulatedSequence()\r\n        };\r\n        var invalidUrlExplanation = StringChecks_1.StringChecks.explainIfInvalidLinkUrl(url);\r\n        if (invalidUrlExplanation) {\r\n            this._parserContext.log.addMessageForTokenSequence(invalidUrlExplanation, excerptParameters.content, nodeForErrorContext);\r\n            return false;\r\n        }\r\n        this._readSpacingAndNewlines(embeddedTokenReader);\r\n        excerptParameters.spacingAfterContent = embeddedTokenReader.tryExtractAccumulatedSequence();\r\n        parameters.urlDestination = url;\r\n        parameters.urlDestinationExcerpt = new Excerpt_1.Excerpt(excerptParameters);\r\n        return true;\r\n    };\r\n    NodeParser.prototype._parseLinkTagCodeDestination = function (embeddedTokenReader, parameters, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        parameters.codeDestination = this._parseDeclarationReference(embeddedTokenReader, tokenSequenceForErrorContext, nodeForErrorContext);\r\n        return !!parameters.codeDestination;\r\n    };\r\n    NodeParser.prototype._parseDeclarationReference = function (tokenReader, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        // The package name can contain characters that look like a member reference.  This means we need to scan forwards\r\n        // to see if there is a \"#\".  However, we need to be careful not to match a \"#\" that is part of a quoted expression.\r\n        var marker = tokenReader.createMarker();\r\n        var hasHash = false;\r\n        // A common mistake is to forget the \"#\" for package name or import path.  The telltale sign\r\n        // of this is mistake is that we see path-only characters such as \"@\" or \"/\" in the beginning\r\n        // where this would be a syntax error for a member reference.\r\n        var lookingForImportCharacters = true;\r\n        var sawImportCharacters = false;\r\n        var done = false;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.DoubleQuote:\r\n                case Token_1.TokenKind.EndOfInput:\r\n                case Token_1.TokenKind.LeftCurlyBracket:\r\n                case Token_1.TokenKind.LeftParenthesis:\r\n                case Token_1.TokenKind.LeftSquareBracket:\r\n                case Token_1.TokenKind.Newline:\r\n                case Token_1.TokenKind.Pipe:\r\n                case Token_1.TokenKind.RightCurlyBracket:\r\n                case Token_1.TokenKind.RightParenthesis:\r\n                case Token_1.TokenKind.RightSquareBracket:\r\n                case Token_1.TokenKind.SingleQuote:\r\n                case Token_1.TokenKind.Spacing:\r\n                    done = true;\r\n                    break;\r\n                case Token_1.TokenKind.PoundSymbol:\r\n                    hasHash = true;\r\n                    done = true;\r\n                    break;\r\n                case Token_1.TokenKind.Slash:\r\n                case Token_1.TokenKind.AtSign:\r\n                    if (lookingForImportCharacters) {\r\n                        sawImportCharacters = true;\r\n                    }\r\n                    tokenReader.readToken();\r\n                    break;\r\n                case Token_1.TokenKind.AsciiWord:\r\n                case Token_1.TokenKind.Period:\r\n                case Token_1.TokenKind.Hyphen:\r\n                    // It's a character that looks like part of a package name or import path,\r\n                    // so don't set lookingForImportCharacters = false\r\n                    tokenReader.readToken();\r\n                    break;\r\n                default:\r\n                    // Once we reach something other than AsciiWord and Period, then the meaning of\r\n                    // slashes and at-signs is no longer obvious.\r\n                    lookingForImportCharacters = false;\r\n                    tokenReader.readToken();\r\n            }\r\n        }\r\n        if (!hasHash && sawImportCharacters) {\r\n            // We saw characters that will be a syntax error if interpreted as a member reference,\r\n            // but would make sense as a package name or import path, but we did not find a \"#\"\r\n            this._parserContext.log.addMessageForTokenSequence('The declaration reference appears to contain a package name or import path,'\r\n                + ' but it is missing the \"#\" delimiter', tokenReader.extractAccumulatedSequence(), nodeForErrorContext);\r\n            return undefined;\r\n        }\r\n        tokenReader.backtrackToMarker(marker);\r\n        var packageNameExcerpt;\r\n        var importPathExcerpt;\r\n        var importHashExcerpt;\r\n        if (hasHash) {\r\n            // If it starts with a \".\" then it's a relative path, not a package name\r\n            if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Period) {\r\n                // Read the package name:\r\n                var scopedPackageName = tokenReader.peekTokenKind() === Token_1.TokenKind.AtSign;\r\n                var finishedScope = false;\r\n                done = false;\r\n                while (!done) {\r\n                    switch (tokenReader.peekTokenKind()) {\r\n                        case Token_1.TokenKind.EndOfInput:\r\n                            // If hasHash=true, then we are expecting to stop when we reach the hash\r\n                            throw new Error('Expecting pound symbol');\r\n                        case Token_1.TokenKind.Slash:\r\n                            // Stop at the first slash, unless this is a scoped package, in which case we stop at the second slash\r\n                            if (scopedPackageName && !finishedScope) {\r\n                                tokenReader.readToken();\r\n                                finishedScope = true;\r\n                            }\r\n                            else {\r\n                                done = true;\r\n                            }\r\n                            break;\r\n                        case Token_1.TokenKind.PoundSymbol:\r\n                            done = true;\r\n                            break;\r\n                        default:\r\n                            tokenReader.readToken();\r\n                    }\r\n                }\r\n                if (!tokenReader.isAccumulatedSequenceEmpty()) {\r\n                    var packageNameExcerptParameters = {\r\n                        content: tokenReader.extractAccumulatedSequence()\r\n                    };\r\n                    this._readSpacingAndNewlines(tokenReader);\r\n                    packageNameExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n                    packageNameExcerpt = new Excerpt_1.Excerpt(packageNameExcerptParameters);\r\n                    // Check that the packageName is syntactically valid\r\n                    var explanation = StringChecks_1.StringChecks.explainIfInvalidPackageName(packageNameExcerpt.content.toString());\r\n                    if (explanation) {\r\n                        this._parserContext.log.addMessageForTokenSequence(explanation, packageNameExcerpt.content, nodeForErrorContext);\r\n                        return undefined;\r\n                    }\r\n                }\r\n            }\r\n            // Read the import path:\r\n            done = false;\r\n            while (!done) {\r\n                switch (tokenReader.peekTokenKind()) {\r\n                    case Token_1.TokenKind.EndOfInput:\r\n                        // If hasHash=true, then we are expecting to stop when we reach the hash\r\n                        throw new Error('Expecting pound symbol');\r\n                    case Token_1.TokenKind.PoundSymbol:\r\n                        done = true;\r\n                        break;\r\n                    default:\r\n                        tokenReader.readToken();\r\n                }\r\n            }\r\n            if (!tokenReader.isAccumulatedSequenceEmpty()) {\r\n                var importPathExcerptParameters = {\r\n                    content: tokenReader.extractAccumulatedSequence()\r\n                };\r\n                this._readSpacingAndNewlines(tokenReader);\r\n                importPathExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n                importPathExcerpt = new Excerpt_1.Excerpt(importPathExcerptParameters);\r\n                // Check that the importPath is syntactically valid\r\n                var explanation = StringChecks_1.StringChecks.explainIfInvalidImportPath(importPathExcerpt.content.toString(), !!packageNameExcerpt);\r\n                if (explanation) {\r\n                    this._parserContext.log.addMessageForTokenSequence(explanation, importPathExcerpt.content, nodeForErrorContext);\r\n                    return undefined;\r\n                }\r\n            }\r\n            // Read the import hash\r\n            if (tokenReader.peekTokenKind() !== Token_1.TokenKind.PoundSymbol) {\r\n                // The above logic should have left us at the PoundSymbol\r\n                throw new Error('Expecting pound symbol');\r\n            }\r\n            tokenReader.readToken();\r\n            var importHashExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            importHashExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            importHashExcerpt = new Excerpt_1.Excerpt(importHashExcerptParameters);\r\n            if (packageNameExcerpt === undefined && importPathExcerpt === undefined) {\r\n                this._parserContext.log.addMessageForTokenSequence('The hash character must be preceded by a package name or import path', importHashExcerpt.content, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n        }\r\n        // Read the member references:\r\n        var memberReferences = [];\r\n        done = false;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.Period:\r\n                case Token_1.TokenKind.LeftParenthesis:\r\n                case Token_1.TokenKind.AsciiWord:\r\n                case Token_1.TokenKind.Colon:\r\n                case Token_1.TokenKind.LeftSquareBracket:\r\n                case Token_1.TokenKind.DoubleQuote:\r\n                    var expectingDot = memberReferences.length > 0;\r\n                    var memberReference = this._parseMemberReference(tokenReader, expectingDot, tokenSequenceForErrorContext, nodeForErrorContext);\r\n                    if (!memberReference) {\r\n                        return undefined;\r\n                    }\r\n                    memberReferences.push(memberReference);\r\n                    break;\r\n                default:\r\n                    done = true;\r\n            }\r\n        }\r\n        if (packageNameExcerpt === undefined && importPathExcerpt === undefined && memberReferences.length === 0) {\r\n            // We didn't find any parts of a declaration reference\r\n            this._parserContext.log.addMessageForTokenSequence('Expecting a declaration reference', tokenSequenceForErrorContext, nodeForErrorContext);\r\n            return undefined;\r\n        }\r\n        return new nodes_1.DocDeclarationReference({\r\n            packageNameExcerpt: packageNameExcerpt,\r\n            packageName: packageNameExcerpt !== undefined ? packageNameExcerpt.content.toString() : undefined,\r\n            importPathExcerpt: importPathExcerpt,\r\n            importPath: importPathExcerpt !== undefined ? importPathExcerpt.content.toString() : undefined,\r\n            importHashExcerpt: importHashExcerpt,\r\n            memberReferences: memberReferences\r\n        });\r\n    };\r\n    NodeParser.prototype._parseMemberReference = function (tokenReader, expectingDot, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        var dotExcerpt;\r\n        // Read the dot operator\r\n        if (expectingDot) {\r\n            if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Period) {\r\n                this._parserContext.log.addMessageForTokenSequence('Expecting a period before the next component'\r\n                    + ' of a declaration reference', tokenSequenceForErrorContext, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n            tokenReader.readToken();\r\n            var dotExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            dotExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            dotExcerpt = new Excerpt_1.Excerpt(dotExcerptParameters);\r\n        }\r\n        // Read the left parenthesis if there is one\r\n        var leftParenthesisExcerpt;\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.LeftParenthesis) {\r\n            tokenReader.readToken();\r\n            var leftParenthesisExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            leftParenthesisExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            leftParenthesisExcerpt = new Excerpt_1.Excerpt(leftParenthesisExcerptParameters);\r\n        }\r\n        var memberIdentifier = undefined;\r\n        var memberSymbol = undefined;\r\n        // Read the member identifier or symbol\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.LeftSquareBracket) {\r\n            memberSymbol = this._parseMemberSymbol(tokenReader, nodeForErrorContext);\r\n            if (!memberSymbol) {\r\n                return undefined;\r\n            }\r\n        }\r\n        else {\r\n            memberIdentifier = this._parseMemberIdentifier(tokenReader, tokenSequenceForErrorContext, nodeForErrorContext);\r\n            if (!memberIdentifier) {\r\n                return undefined;\r\n            }\r\n        }\r\n        // Read the colon\r\n        var colonExcerpt;\r\n        var selector = undefined;\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.Colon) {\r\n            tokenReader.readToken();\r\n            var colonExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            colonExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            colonExcerpt = new Excerpt_1.Excerpt(colonExcerptParameters);\r\n            if (!leftParenthesisExcerpt) {\r\n                // In the current TSDoc draft standard, a member reference with a selector requires the parentheses.\r\n                // It would be reasonable to make the parentheses optional, and we are contemplating simplifying the\r\n                // notation in the future.  But for now the parentheses are required.\r\n                this._parserContext.log.addMessageForTokenSequence('Syntax error in declaration reference: the member selector must be enclosed in parentheses', colonExcerpt.content, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n            // If there is a colon, then read the selector\r\n            selector = this._parseMemberSelector(tokenReader, colonExcerptParameters.content, nodeForErrorContext);\r\n            if (!selector) {\r\n                return undefined;\r\n            }\r\n        }\r\n        else {\r\n            if (leftParenthesisExcerpt) {\r\n                this._parserContext.log.addMessageForTokenSequence('Expecting a colon after the identifier because'\r\n                    + ' the expression is in parentheses', leftParenthesisExcerpt.content, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n        }\r\n        // Read the right parenthesis\r\n        var rightParenthesisExcerpt;\r\n        if (leftParenthesisExcerpt) {\r\n            if (tokenReader.peekTokenKind() !== Token_1.TokenKind.RightParenthesis) {\r\n                this._parserContext.log.addMessageForTokenSequence('Expecting a matching right parenthesis', leftParenthesisExcerpt.content, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n            tokenReader.readToken();\r\n            var rightParenthesisExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            rightParenthesisExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            rightParenthesisExcerpt = new Excerpt_1.Excerpt(rightParenthesisExcerptParameters);\r\n        }\r\n        return new nodes_1.DocMemberReference({\r\n            hasDot: dotExcerpt !== undefined,\r\n            dotExcerpt: dotExcerpt,\r\n            leftParenthesisExcerpt: leftParenthesisExcerpt,\r\n            memberIdentifier: memberIdentifier,\r\n            memberSymbol: memberSymbol,\r\n            colonExcerpt: colonExcerpt,\r\n            selector: selector,\r\n            rightParenthesisExcerpt: rightParenthesisExcerpt\r\n        });\r\n    };\r\n    NodeParser.prototype._parseMemberSymbol = function (tokenReader, nodeForErrorContext) {\r\n        // Read the \"[\"\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.LeftSquareBracket) {\r\n            // This should be impossible since the caller ensures that peekTokenKind() === TokenKind.LeftSquareBracket\r\n            throw new Error('Expecting \"[\"');\r\n        }\r\n        tokenReader.readToken();\r\n        var leftBracketExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        leftBracketExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        // Read the declaration reference\r\n        var declarationReference = this._parseDeclarationReference(tokenReader, leftBracketExcerptParameters.content, nodeForErrorContext);\r\n        if (!declarationReference) {\r\n            this._parserContext.log.addMessageForTokenSequence('Missing declaration reference in symbol reference', leftBracketExcerptParameters.content, nodeForErrorContext);\r\n            return undefined;\r\n        }\r\n        // Read the \"]\"\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.RightSquareBracket) {\r\n            this._parserContext.log.addMessageForTokenSequence('Missing closing square bracket for symbol reference', leftBracketExcerptParameters.content, nodeForErrorContext);\r\n            return undefined;\r\n        }\r\n        tokenReader.readToken();\r\n        var rightBracketExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        rightBracketExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        return new nodes_1.DocMemberSymbol({\r\n            leftBracketExcerpt: new Excerpt_1.Excerpt(leftBracketExcerptParameters),\r\n            symbolReference: declarationReference,\r\n            rightBracketExcerpt: new Excerpt_1.Excerpt(rightBracketExcerptParameters)\r\n        });\r\n    };\r\n    NodeParser.prototype._parseMemberIdentifier = function (tokenReader, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        // Is this a quoted identifier?\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.DoubleQuote) {\r\n            // Read the opening '\"'\r\n            tokenReader.readToken();\r\n            var leftQuoteExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            // Read the text inside the quotes\r\n            while (tokenReader.peekTokenKind() !== Token_1.TokenKind.DoubleQuote) {\r\n                if (tokenReader.peekTokenKind() === Token_1.TokenKind.EndOfInput) {\r\n                    this._parserContext.log.addMessageForTokenSequence('Unexpected end of input inside quoted member identifier', leftQuoteExcerptParameters.content, nodeForErrorContext);\r\n                    return undefined;\r\n                }\r\n                tokenReader.readToken();\r\n            }\r\n            if (tokenReader.isAccumulatedSequenceEmpty()) {\r\n                this._parserContext.log.addMessageForTokenSequence('The quoted identifier cannot be empty', leftQuoteExcerptParameters.content, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n            var identifierExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            // Read the closing '\"\"\r\n            tokenReader.readToken(); // read the quote\r\n            var rightQuoteExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            rightQuoteExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            return new nodes_1.DocMemberIdentifier({\r\n                leftQuoteExcerpt: new Excerpt_1.Excerpt(leftQuoteExcerptParameters),\r\n                identifierExcerpt: new Excerpt_1.Excerpt(identifierExcerptParameters),\r\n                identifier: identifierExcerptParameters.content.toString(),\r\n                rightQuoteExcerpt: new Excerpt_1.Excerpt(rightQuoteExcerptParameters)\r\n            });\r\n        }\r\n        else {\r\n            // Otherwise assume it's a valid TypeScript identifier\r\n            if (tokenReader.peekTokenKind() !== Token_1.TokenKind.AsciiWord) {\r\n                this._parserContext.log.addMessageForTokenSequence('Syntax error in declaration reference: expecting a member identifier', tokenSequenceForErrorContext, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n            var identifier = tokenReader.readToken().toString();\r\n            var identifierExcerptParameters = {\r\n                content: tokenReader.extractAccumulatedSequence()\r\n            };\r\n            this._readSpacingAndNewlines(tokenReader);\r\n            identifierExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n            var explanation = StringChecks_1.StringChecks.explainIfInvalidUnquotedIdentifier(identifier);\r\n            if (explanation) {\r\n                this._parserContext.log.addMessageForTokenSequence(explanation, identifierExcerptParameters.content, nodeForErrorContext);\r\n                return undefined;\r\n            }\r\n            return new nodes_1.DocMemberIdentifier({\r\n                identifierExcerpt: new Excerpt_1.Excerpt(identifierExcerptParameters),\r\n                identifier: identifier\r\n            });\r\n        }\r\n    };\r\n    NodeParser.prototype._parseMemberSelector = function (tokenReader, tokenSequenceForErrorContext, nodeForErrorContext) {\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.AsciiWord) {\r\n            this._parserContext.log.addMessageForTokenSequence('Expecting a selector label after the colon', tokenSequenceForErrorContext, nodeForErrorContext);\r\n        }\r\n        var selector = tokenReader.readToken().toString();\r\n        var selectorExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        selectorExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        var docMemberSelector = new nodes_1.DocMemberSelector({\r\n            excerpt: new Excerpt_1.Excerpt(selectorExcerptParameters),\r\n            selector: selector\r\n        });\r\n        if (docMemberSelector.errorMessage) {\r\n            this._parserContext.log.addMessageForTokenSequence(docMemberSelector.errorMessage, selectorExcerptParameters.content, nodeForErrorContext);\r\n            return undefined;\r\n        }\r\n        return docMemberSelector;\r\n    };\r\n    NodeParser.prototype._parseHtmlStartTag = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var marker = tokenReader.createMarker();\r\n        // Read the \"<\" delimiter\r\n        var lessThanToken = tokenReader.readToken();\r\n        if (lessThanToken.kind !== Token_1.TokenKind.LessThan) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting an HTML tag starting with \"<\"');\r\n        }\r\n        // NOTE: CommonMark does not permit whitespace after the \"<\"\r\n        var openingDelimiterExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        // Read the element name\r\n        var elementName = this._parseHtmlName(tokenReader);\r\n        if (isFailure(elementName)) {\r\n            return this._backtrackAndCreateErrorForFailure(tokenReader, marker, 'Invalid HTML element: ', elementName);\r\n        }\r\n        var elementNameExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        var spacingAfterElementName = this._readSpacingAndNewlines(tokenReader);\r\n        elementNameExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        var htmlAttributes = [];\r\n        // Read the attributes until we see a \">\" or \"/>\"\r\n        while (tokenReader.peekTokenKind() === Token_1.TokenKind.AsciiWord) {\r\n            // Read the attribute\r\n            var attributeNode = this._parseHtmlAttribute(tokenReader);\r\n            if (isFailure(attributeNode)) {\r\n                return this._backtrackAndCreateErrorForFailure(tokenReader, marker, 'The HTML element has an invalid attribute: ', attributeNode);\r\n            }\r\n            htmlAttributes.push(attributeNode);\r\n        }\r\n        // Read the closing \"/>\" or \">\" as the Excerpt.suffix\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var endDelimiterMarker = tokenReader.createMarker();\r\n        var selfClosingTag = false;\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.Slash) {\r\n            tokenReader.readToken();\r\n            selfClosingTag = true;\r\n        }\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.GreaterThan) {\r\n            var failure = this._createFailureForTokensSince(tokenReader, 'Expecting an attribute or \">\" or \"/>\"', endDelimiterMarker);\r\n            return this._backtrackAndCreateErrorForFailure(tokenReader, marker, 'The HTML tag has invalid syntax: ', failure);\r\n        }\r\n        tokenReader.readToken();\r\n        var closingDelimiterExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        // NOTE: We don't read excerptParameters.separator here, since if there is any it\r\n        // will be represented as DocPlainText.\r\n        return new nodes_1.DocHtmlStartTag({\r\n            openingDelimiterExcerpt: new Excerpt_1.Excerpt(openingDelimiterExcerptParameters),\r\n            elementNameExcerpt: new Excerpt_1.Excerpt(elementNameExcerptParameters),\r\n            elementName: elementName,\r\n            spacingAfterElementName: spacingAfterElementName,\r\n            htmlAttributes: htmlAttributes,\r\n            selfClosingTag: selfClosingTag,\r\n            closingDelimiterExcerpt: new Excerpt_1.Excerpt(closingDelimiterExcerptParameters)\r\n        });\r\n    };\r\n    NodeParser.prototype._parseHtmlAttribute = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        // Read the attribute name\r\n        var attributeName = this._parseHtmlName(tokenReader);\r\n        if (isFailure(attributeName)) {\r\n            return attributeName;\r\n        }\r\n        var attributeNameExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        var spacingAfterAttributeName = this._readSpacingAndNewlines(tokenReader);\r\n        attributeNameExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        // Read the equals\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Equals) {\r\n            return this._createFailureForToken(tokenReader, 'Expecting \"=\" after HTML attribute name');\r\n        }\r\n        tokenReader.readToken();\r\n        var equalsExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        var spacingAfterEquals = this._readSpacingAndNewlines(tokenReader);\r\n        equalsExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        // Read the attribute value\r\n        var attributeValue = this._parseHtmlString(tokenReader);\r\n        if (isFailure(attributeValue)) {\r\n            return attributeValue;\r\n        }\r\n        var attributeValueExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        var spacingAfterAttributeValue = this._readSpacingAndNewlines(tokenReader);\r\n        attributeValueExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        return new nodes_1.DocHtmlAttribute({\r\n            attributeNameExcerpt: new Excerpt_1.Excerpt(attributeNameExcerptParameters),\r\n            attributeName: attributeName,\r\n            spacingAfterAttributeName: spacingAfterAttributeName,\r\n            equalsExcerpt: new Excerpt_1.Excerpt(equalsExcerptParameters),\r\n            spacingAfterEquals: spacingAfterEquals,\r\n            attributeValueExcerpt: new Excerpt_1.Excerpt(attributeValueExcerptParameters),\r\n            attributeValue: attributeValue,\r\n            spacingAfterAttributeValue: spacingAfterAttributeValue\r\n        });\r\n    };\r\n    NodeParser.prototype._parseHtmlString = function (tokenReader) {\r\n        var marker = tokenReader.createMarker();\r\n        var quoteTokenKind = tokenReader.peekTokenKind();\r\n        if (quoteTokenKind !== Token_1.TokenKind.DoubleQuote && quoteTokenKind !== Token_1.TokenKind.SingleQuote) {\r\n            return this._createFailureForToken(tokenReader, 'Expecting an HTML string starting with a single-quote or double-quote character');\r\n        }\r\n        tokenReader.readToken();\r\n        var textWithoutQuotes = '';\r\n        while (true) {\r\n            var peekedTokenKind = tokenReader.peekTokenKind();\r\n            // Did we find the matching token?\r\n            if (peekedTokenKind === quoteTokenKind) {\r\n                tokenReader.readToken(); // extract the quote\r\n                break;\r\n            }\r\n            if (peekedTokenKind === Token_1.TokenKind.EndOfInput || peekedTokenKind === Token_1.TokenKind.Newline) {\r\n                return this._createFailureForToken(tokenReader, 'The HTML string is missing its closing quote', marker);\r\n            }\r\n            textWithoutQuotes += tokenReader.readToken().toString();\r\n        }\r\n        // The next attribute cannot start immediately after this one\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.AsciiWord) {\r\n            return this._createFailureForToken(tokenReader, 'The next character after a closing quote must be spacing or punctuation');\r\n        }\r\n        return textWithoutQuotes;\r\n    };\r\n    NodeParser.prototype._parseHtmlEndTag = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var marker = tokenReader.createMarker();\r\n        // Read the \"</\" delimiter\r\n        var lessThanToken = tokenReader.peekToken();\r\n        if (lessThanToken.kind !== Token_1.TokenKind.LessThan) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting an HTML tag starting with \"</\"');\r\n        }\r\n        tokenReader.readToken();\r\n        var slashToken = tokenReader.peekToken();\r\n        if (slashToken.kind !== Token_1.TokenKind.Slash) {\r\n            return this._backtrackAndCreateError(tokenReader, marker, 'Expecting an HTML tag starting with \"</\"');\r\n        }\r\n        tokenReader.readToken();\r\n        // NOTE: Spaces are not permitted here\r\n        // https://www.w3.org/TR/html5/syntax.html#end-tags\r\n        var openingDelimiterExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        // Read the tag name\r\n        var elementName = this._parseHtmlName(tokenReader);\r\n        if (isFailure(elementName)) {\r\n            return this._backtrackAndCreateErrorForFailure(tokenReader, marker, 'Expecting an HTML element name: ', elementName);\r\n        }\r\n        var elementNameExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        this._readSpacingAndNewlines(tokenReader);\r\n        elementNameExcerptParameters.spacingAfterContent = tokenReader.tryExtractAccumulatedSequence();\r\n        // Read the closing \">\"\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.GreaterThan) {\r\n            var failure = this._createFailureForToken(tokenReader, 'Expecting a closing \">\" for the HTML tag');\r\n            return this._backtrackAndCreateErrorForFailure(tokenReader, marker, '', failure);\r\n        }\r\n        tokenReader.readToken();\r\n        var closingDelimiterExcerptParameters = {\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        };\r\n        return new nodes_1.DocHtmlEndTag({\r\n            openingDelimiterExcerpt: new Excerpt_1.Excerpt(openingDelimiterExcerptParameters),\r\n            elementNameExcerpt: new Excerpt_1.Excerpt(elementNameExcerptParameters),\r\n            elementName: elementName,\r\n            closingDelimiterExcerpt: new Excerpt_1.Excerpt(closingDelimiterExcerptParameters)\r\n        });\r\n    };\r\n    /**\r\n     * Parses an HTML name such as an element name or attribute name.\r\n     */\r\n    NodeParser.prototype._parseHtmlName = function (tokenReader) {\r\n        var htmlName = '';\r\n        var marker = tokenReader.createMarker();\r\n        if (tokenReader.peekTokenKind() === Token_1.TokenKind.Spacing) {\r\n            return this._createFailureForTokensSince(tokenReader, 'A space is not allowed here', marker);\r\n        }\r\n        var done = false;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.AsciiWord:\r\n                case Token_1.TokenKind.Hyphen:\r\n                    htmlName += tokenReader.readToken().toString();\r\n                    break;\r\n                default:\r\n                    done = true;\r\n                    break;\r\n            }\r\n        }\r\n        if (htmlName.length === 0) {\r\n            return this._createFailureForToken(tokenReader, 'Expecting an HTML name');\r\n        }\r\n        if (!NodeParser.htmlNameRegExp.test(htmlName)) {\r\n            return this._createFailureForTokensSince(tokenReader, 'An HTML name must be a sequence of letters separated by hyphens', marker);\r\n        }\r\n        return htmlName;\r\n    };\r\n    NodeParser.prototype._parseFencedCode = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var startMarker = tokenReader.createMarker();\r\n        var endOfOpeningDelimiterMarker = startMarker + 2;\r\n        switch (tokenReader.peekPreviousTokenKind()) {\r\n            case Token_1.TokenKind.Newline:\r\n            case Token_1.TokenKind.EndOfInput:\r\n                break;\r\n            default:\r\n                return this._backtrackAndCreateErrorRange(tokenReader, startMarker, \r\n                // include the three backticks so they don't get reinterpreted as a code span\r\n                endOfOpeningDelimiterMarker, 'The opening backtick for a code fence must appear at the start of the line');\r\n        }\r\n        // Read the opening ``` delimiter\r\n        var openingDelimiter = '';\r\n        openingDelimiter += tokenReader.readToken();\r\n        openingDelimiter += tokenReader.readToken();\r\n        openingDelimiter += tokenReader.readToken();\r\n        if (openingDelimiter !== '```') {\r\n            // This would be a parser bug -- the caller of _parseFencedCode() should have verified this while\r\n            // looking ahead to distinguish code spans/fences\r\n            throw new Error('Expecting three backticks');\r\n        }\r\n        var openingDelimiterSequence = tokenReader.extractAccumulatedSequence();\r\n        // Read any spaces after the delimiter,\r\n        // but NOT the Newline since that goes with the language particle\r\n        while (tokenReader.peekTokenKind() === Token_1.TokenKind.Spacing) {\r\n            tokenReader.readToken();\r\n        }\r\n        var openingDelimiterExcerpt = new Excerpt_1.Excerpt({\r\n            content: openingDelimiterSequence,\r\n            spacingAfterContent: tokenReader.tryExtractAccumulatedSequence()\r\n        });\r\n        // Read the language specifier (if present) and newline\r\n        var done = false;\r\n        var startOfPaddingMarker = undefined;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.Spacing:\r\n                case Token_1.TokenKind.Newline:\r\n                    if (startOfPaddingMarker === undefined) {\r\n                        // Starting a new run of spacing characters\r\n                        startOfPaddingMarker = tokenReader.createMarker();\r\n                    }\r\n                    if (tokenReader.peekTokenKind() === Token_1.TokenKind.Newline) {\r\n                        done = true;\r\n                    }\r\n                    tokenReader.readToken();\r\n                    break;\r\n                case Token_1.TokenKind.Backtick:\r\n                    var failure = this._createFailureForToken(tokenReader, 'The language specifier cannot contain backtick characters');\r\n                    return this._backtrackAndCreateErrorRangeForFailure(tokenReader, startMarker, endOfOpeningDelimiterMarker, 'Error parsing code fence: ', failure);\r\n                case Token_1.TokenKind.EndOfInput:\r\n                    var failure2 = this._createFailureForToken(tokenReader, 'Missing closing delimiter');\r\n                    return this._backtrackAndCreateErrorRangeForFailure(tokenReader, startMarker, endOfOpeningDelimiterMarker, 'Error parsing code fence: ', failure2);\r\n                default:\r\n                    // more non-spacing content\r\n                    startOfPaddingMarker = undefined;\r\n                    tokenReader.readToken();\r\n                    break;\r\n            }\r\n        }\r\n        // At this point, we must have accumulated at least a newline token.\r\n        // Example: \"pov-ray sdl    \\n\"\r\n        var languageSequence = tokenReader.extractAccumulatedSequence();\r\n        var languageExcerpt = new Excerpt_1.Excerpt({\r\n            // Example: \"pov-ray sdl\"\r\n            content: languageSequence.getNewSequence(languageSequence.startIndex, startOfPaddingMarker),\r\n            // Example: \"    \\n\"\r\n            spacingAfterContent: languageSequence.getNewSequence(startOfPaddingMarker, languageSequence.endIndex)\r\n        });\r\n        // Read the code content until we see the closing ``` delimiter\r\n        var codeEndMarker = -1;\r\n        done = false;\r\n        var tokenBeforeDelimiter;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.EndOfInput:\r\n                    var failure2 = this._createFailureForToken(tokenReader, 'Missing closing delimiter');\r\n                    return this._backtrackAndCreateErrorRangeForFailure(tokenReader, startMarker, endOfOpeningDelimiterMarker, 'Error parsing code fence: ', failure2);\r\n                case Token_1.TokenKind.Newline:\r\n                    tokenBeforeDelimiter = tokenReader.readToken();\r\n                    codeEndMarker = tokenReader.createMarker();\r\n                    while (tokenReader.peekTokenKind() === Token_1.TokenKind.Spacing) {\r\n                        tokenBeforeDelimiter = tokenReader.readToken();\r\n                    }\r\n                    if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Backtick) {\r\n                        break;\r\n                    }\r\n                    tokenReader.readToken(); // first backtick\r\n                    if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Backtick) {\r\n                        break;\r\n                    }\r\n                    tokenReader.readToken(); // second backtick\r\n                    if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Backtick) {\r\n                        break;\r\n                    }\r\n                    tokenReader.readToken(); // third backtick\r\n                    done = true;\r\n                    break;\r\n                default:\r\n                    tokenReader.readToken();\r\n                    break;\r\n            }\r\n        }\r\n        if (tokenBeforeDelimiter.kind !== Token_1.TokenKind.Newline) {\r\n            this._parserContext.log.addMessageForTextRange('The closing delimiter for a code fence must not be indented', tokenBeforeDelimiter.range);\r\n        }\r\n        // Example: \"code 1\\ncode 2\\n   ```\"\r\n        var codeAndDelimiterSequence = tokenReader.extractAccumulatedSequence();\r\n        var codeExcerpt = new Excerpt_1.Excerpt({\r\n            content: codeAndDelimiterSequence.getNewSequence(codeAndDelimiterSequence.startIndex, codeEndMarker)\r\n        });\r\n        // Read the spacing and newline after the closing delimiter\r\n        done = false;\r\n        while (!done) {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.Spacing:\r\n                    tokenReader.readToken();\r\n                    break;\r\n                case Token_1.TokenKind.Newline:\r\n                    done = true;\r\n                    tokenReader.readToken();\r\n                    break;\r\n                case Token_1.TokenKind.EndOfInput:\r\n                    done = true;\r\n                    break;\r\n                default:\r\n                    this._parserContext.log.addMessageForTextRange('Unexpected characters after closing delimiter for code fence', tokenReader.peekToken().range);\r\n                    done = true;\r\n                    break;\r\n            }\r\n        }\r\n        var closingDelimiterExcerpt = new Excerpt_1.Excerpt({\r\n            // Example: \"```\"\r\n            content: codeAndDelimiterSequence.getNewSequence(codeEndMarker, codeAndDelimiterSequence.endIndex),\r\n            // Example: \"   \\n\"\r\n            spacingAfterContent: tokenReader.tryExtractAccumulatedSequence()\r\n        });\r\n        return new nodes_1.DocFencedCode({\r\n            openingDelimiterExcerpt: openingDelimiterExcerpt,\r\n            languageExcerpt: languageExcerpt,\r\n            language: languageExcerpt.content.toString(),\r\n            codeExcerpt: codeExcerpt,\r\n            code: codeExcerpt.content.toString(),\r\n            closingDelimiterExcerpt: closingDelimiterExcerpt\r\n        });\r\n    };\r\n    NodeParser.prototype._parseCodeSpan = function (tokenReader) {\r\n        tokenReader.assertAccumulatedSequenceIsEmpty();\r\n        var marker = tokenReader.createMarker();\r\n        // Parse the opening backtick\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.Backtick) {\r\n            return this._createError(tokenReader, 'Expecting a code span starting with a backtick character \"`\"');\r\n        }\r\n        tokenReader.readToken(); // read the backtick\r\n        var openingDelimiterExcerpt = new Excerpt_1.Excerpt({\r\n            content: tokenReader.extractAccumulatedSequence()\r\n        });\r\n        var codeExcerpt;\r\n        var closingDelimiterExcerpt;\r\n        // Parse the content backtick\r\n        while (true) {\r\n            var peekedTokenKind = tokenReader.peekTokenKind();\r\n            // Did we find the matching token?\r\n            if (peekedTokenKind === Token_1.TokenKind.Backtick) {\r\n                if (tokenReader.isAccumulatedSequenceEmpty()) {\r\n                    return this._backtrackAndCreateErrorRange(tokenReader, marker, marker + 1, 'A code span must contain at least one character between the backticks');\r\n                }\r\n                codeExcerpt = new Excerpt_1.Excerpt({\r\n                    content: tokenReader.extractAccumulatedSequence()\r\n                });\r\n                tokenReader.readToken();\r\n                closingDelimiterExcerpt = new Excerpt_1.Excerpt({\r\n                    content: tokenReader.extractAccumulatedSequence()\r\n                });\r\n                break;\r\n            }\r\n            if (peekedTokenKind === Token_1.TokenKind.EndOfInput || peekedTokenKind === Token_1.TokenKind.Newline) {\r\n                return this._backtrackAndCreateError(tokenReader, marker, 'The code span is missing its closing backtick');\r\n            }\r\n            tokenReader.readToken();\r\n        }\r\n        return new nodes_1.DocCodeSpan({\r\n            openingDelimiterExcerpt: openingDelimiterExcerpt,\r\n            codeExcerpt: codeExcerpt,\r\n            code: codeExcerpt.content.toString(),\r\n            closingDelimiterExcerpt: closingDelimiterExcerpt\r\n        });\r\n    };\r\n    NodeParser.prototype._readSpacingAndNewlines = function (tokenReader) {\r\n        var result = '';\r\n        var done = false;\r\n        do {\r\n            switch (tokenReader.peekTokenKind()) {\r\n                case Token_1.TokenKind.Spacing:\r\n                case Token_1.TokenKind.Newline:\r\n                    result += tokenReader.readToken().toString();\r\n                    break;\r\n                default:\r\n                    done = true;\r\n                    break;\r\n            }\r\n        } while (!done);\r\n        return result;\r\n    };\r\n    /**\r\n     * Read the next token, and report it as a DocErrorText node.\r\n     */\r\n    NodeParser.prototype._createError = function (tokenReader, errorMessage) {\r\n        tokenReader.readToken();\r\n        var tokenSequence = tokenReader.extractAccumulatedSequence();\r\n        var docErrorText = new nodes_1.DocErrorText({\r\n            excerpt: new Excerpt_1.Excerpt({ content: tokenSequence }),\r\n            text: tokenSequence.toString(),\r\n            errorMessage: errorMessage,\r\n            errorLocation: tokenSequence\r\n        });\r\n        this._parserContext.log.addMessageForDocErrorText(docErrorText);\r\n        return docErrorText;\r\n    };\r\n    /**\r\n     * Rewind to the specified marker, read the next token, and report it as a DocErrorText node.\r\n     */\r\n    NodeParser.prototype._backtrackAndCreateError = function (tokenReader, marker, errorMessage) {\r\n        tokenReader.backtrackToMarker(marker);\r\n        return this._createError(tokenReader, errorMessage);\r\n    };\r\n    /**\r\n     * Rewind to the errorStartMarker, read the tokens up to and including errorInclusiveEndMarker,\r\n     * and report it as a DocErrorText node.\r\n     */\r\n    NodeParser.prototype._backtrackAndCreateErrorRange = function (tokenReader, errorStartMarker, errorInclusiveEndMarker, errorMessage) {\r\n        tokenReader.backtrackToMarker(errorStartMarker);\r\n        while (tokenReader.createMarker() !== errorInclusiveEndMarker) {\r\n            tokenReader.readToken();\r\n        }\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.EndOfInput) {\r\n            tokenReader.readToken();\r\n        }\r\n        var tokenSequence = tokenReader.extractAccumulatedSequence();\r\n        var docErrorText = new nodes_1.DocErrorText({\r\n            excerpt: new Excerpt_1.Excerpt({ content: tokenSequence }),\r\n            text: tokenSequence.toString(),\r\n            errorMessage: errorMessage,\r\n            errorLocation: tokenSequence\r\n        });\r\n        this._parserContext.log.addMessageForDocErrorText(docErrorText);\r\n        return docErrorText;\r\n    };\r\n    /**\r\n     * Rewind to the specified marker, read the next token, and report it as a DocErrorText node\r\n     * whose location is based on an IFailure.\r\n     */\r\n    NodeParser.prototype._backtrackAndCreateErrorForFailure = function (tokenReader, marker, errorMessagePrefix, failure) {\r\n        tokenReader.backtrackToMarker(marker);\r\n        tokenReader.readToken();\r\n        var tokenSequence = tokenReader.extractAccumulatedSequence();\r\n        var docErrorText = new nodes_1.DocErrorText({\r\n            excerpt: new Excerpt_1.Excerpt({ content: tokenSequence }),\r\n            text: tokenSequence.toString(),\r\n            errorMessage: errorMessagePrefix + failure.failureMessage,\r\n            errorLocation: failure.failureLocation\r\n        });\r\n        this._parserContext.log.addMessageForDocErrorText(docErrorText);\r\n        return docErrorText;\r\n    };\r\n    /**\r\n     * Rewind to the errorStartMarker, read the tokens up to and including errorInclusiveEndMarker,\r\n     * and report it as a DocErrorText node whose location is based on an IFailure.\r\n     */\r\n    NodeParser.prototype._backtrackAndCreateErrorRangeForFailure = function (tokenReader, errorStartMarker, errorInclusiveEndMarker, errorMessagePrefix, failure) {\r\n        tokenReader.backtrackToMarker(errorStartMarker);\r\n        while (tokenReader.createMarker() !== errorInclusiveEndMarker) {\r\n            tokenReader.readToken();\r\n        }\r\n        if (tokenReader.peekTokenKind() !== Token_1.TokenKind.EndOfInput) {\r\n            tokenReader.readToken();\r\n        }\r\n        var tokenSequence = tokenReader.extractAccumulatedSequence();\r\n        var docErrorText = new nodes_1.DocErrorText({\r\n            excerpt: new Excerpt_1.Excerpt({ content: tokenSequence }),\r\n            text: tokenSequence.toString(),\r\n            errorMessage: errorMessagePrefix + failure.failureMessage,\r\n            errorLocation: failure.failureLocation\r\n        });\r\n        this._parserContext.log.addMessageForDocErrorText(docErrorText);\r\n        return docErrorText;\r\n    };\r\n    /**\r\n     * Creates an IFailure whose TokenSequence is a single token.  If a marker is not specified,\r\n     * then it is the current token.\r\n     */\r\n    NodeParser.prototype._createFailureForToken = function (tokenReader, failureMessage, tokenMarker) {\r\n        if (!tokenMarker) {\r\n            tokenMarker = tokenReader.createMarker();\r\n        }\r\n        var tokenSequence = new TokenSequence_1.TokenSequence({\r\n            parserContext: this._parserContext,\r\n            startIndex: tokenMarker,\r\n            endIndex: tokenMarker + 1\r\n        });\r\n        return {\r\n            failureMessage: failureMessage,\r\n            failureLocation: tokenSequence\r\n        };\r\n    };\r\n    /**\r\n     * Creates an IFailure whose TokenSequence starts from the specified marker and\r\n     * encompasses all tokens read since then.  If none were read, then the next token used.\r\n     */\r\n    NodeParser.prototype._createFailureForTokensSince = function (tokenReader, failureMessage, startMarker) {\r\n        var endMarker = tokenReader.createMarker();\r\n        if (endMarker < startMarker) {\r\n            // This would be a parser bug\r\n            throw new Error('Invalid startMarker');\r\n        }\r\n        if (endMarker === startMarker) {\r\n            ++endMarker;\r\n        }\r\n        var tokenSequence = new TokenSequence_1.TokenSequence({\r\n            parserContext: this._parserContext,\r\n            startIndex: startMarker,\r\n            endIndex: endMarker\r\n        });\r\n        return {\r\n            failureMessage: failureMessage,\r\n            failureLocation: tokenSequence\r\n        };\r\n    };\r\n    // https://www.w3.org/TR/html5/syntax.html#tag-name\r\n    // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n    NodeParser.htmlNameRegExp = /^[a-z]+(\\-[a-z]+)*$/i;\r\n    return NodeParser;\r\n}());\r\nexports.NodeParser = NodeParser;\r\n//# sourceMappingURL=NodeParser.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar nodes_1 = require(\"../nodes\");\r\n/**\r\n * The ParagraphSplitter is a secondary stage that runs after the NodeParser has constructed\r\n * the DocComment.  It splits DocParagraph nodes into multiple paragraphs by looking for\r\n * paragraph delimiters.  Following CommonMark conventions, paragraphs are delimited by\r\n * one or more blank lines.  (These lines end with SoftBreak nodes.)  The blank lines are\r\n * not discarded.  Instead, they are attached to the preceding paragraph.  If the DocParagraph\r\n * starts with blank lines, they are preserved to avoid creating a paragraph containing only\r\n * whitespace.\r\n */\r\nvar ParagraphSplitter = /** @class */ (function () {\r\n    function ParagraphSplitter() {\r\n    }\r\n    /**\r\n     * Split all paragraphs belonging to the provided DocComment.\r\n     */\r\n    ParagraphSplitter.splitParagraphs = function (docComment) {\r\n        for (var _i = 0, _a = docComment.getChildNodes(); _i < _a.length; _i++) {\r\n            var node = _a[_i];\r\n            if (node instanceof nodes_1.DocSection) {\r\n                ParagraphSplitter.splitParagraphsForSection(node);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Split all paragraphs belonging to the provided DocSection.\r\n     */\r\n    ParagraphSplitter.splitParagraphsForSection = function (docSection) {\r\n        var inputNodes = docSection.nodes;\r\n        var outputNodes = [];\r\n        for (var _i = 0, inputNodes_1 = inputNodes; _i < inputNodes_1.length; _i++) {\r\n            var oldNode = inputNodes_1[_i];\r\n            if (oldNode.kind === \"Paragraph\" /* Paragraph */) {\r\n                ParagraphSplitter._splitParagraph(oldNode, outputNodes);\r\n            }\r\n            else {\r\n                outputNodes.push(oldNode);\r\n            }\r\n        }\r\n        // Replace the inputNodes with the outputNodes\r\n        docSection.clearNodes();\r\n        docSection.appendNodes(outputNodes);\r\n    };\r\n    ParagraphSplitter._splitParagraph = function (oldParagraph, outputNodes) {\r\n        var inputParagraphNodes = oldParagraph.nodes;\r\n        var currentParagraph = new nodes_1.DocParagraph({});\r\n        outputNodes.push(currentParagraph);\r\n        var state = 0 /* Start */;\r\n        var currentIndex = 0;\r\n        while (currentIndex < inputParagraphNodes.length) {\r\n            // Scan forwards to the end of the line\r\n            var isBlankLine = true;\r\n            var lineEndIndex = currentIndex; // non-inclusive\r\n            do {\r\n                var node = inputParagraphNodes[lineEndIndex++];\r\n                if (node.kind === \"SoftBreak\" /* SoftBreak */) {\r\n                    break;\r\n                }\r\n                if (isBlankLine) {\r\n                    if (!this._isWhitespace(node)) {\r\n                        isBlankLine = false;\r\n                    }\r\n                }\r\n            } while (lineEndIndex < inputParagraphNodes.length);\r\n            // At this point, the line and SoftBreak will be in inputParagraphNodes.slice(currentIndex, lineEndIndex)\r\n            switch (state) {\r\n                case 0 /* Start */:\r\n                    // We're skipping any blank lines that start the first paragraph\r\n                    if (!isBlankLine) {\r\n                        state = 1 /* AwaitingTrailer */;\r\n                    }\r\n                    break;\r\n                case 1 /* AwaitingTrailer */:\r\n                    // We already saw some content, so now we're looking for a blank line that starts the trailer\r\n                    // at the end of this paragraph\r\n                    if (isBlankLine) {\r\n                        state = 2 /* ReadingTrailer */;\r\n                    }\r\n                    break;\r\n                case 2 /* ReadingTrailer */:\r\n                    // We already found the trailer, so now we're looking for a non-blank line that will\r\n                    // begin a new paragraph\r\n                    if (!isBlankLine) {\r\n                        // Start a new paragraph\r\n                        currentParagraph = new nodes_1.DocParagraph({});\r\n                        outputNodes.push(currentParagraph);\r\n                        state = 1 /* AwaitingTrailer */;\r\n                    }\r\n                    break;\r\n            }\r\n            // Append the line onto the current paragraph\r\n            for (var i = currentIndex; i < lineEndIndex; ++i) {\r\n                currentParagraph.appendNode(inputParagraphNodes[i]);\r\n            }\r\n            currentIndex = lineEndIndex;\r\n        }\r\n    };\r\n    ParagraphSplitter._isWhitespace = function (node) {\r\n        switch (node.kind) {\r\n            case \"PlainText\" /* PlainText */:\r\n                var docPlainText = node;\r\n                return ParagraphSplitter._whitespaceRegExp.test(docPlainText.text);\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    ParagraphSplitter._whitespaceRegExp = /^\\s*$/;\r\n    return ParagraphSplitter;\r\n}());\r\nexports.ParagraphSplitter = ParagraphSplitter;\r\n//# sourceMappingURL=ParagraphSplitter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TextRange_1 = require(\"./TextRange\");\r\nvar nodes_1 = require(\"../nodes\");\r\nvar ParserMessageLog_1 = require(\"./ParserMessageLog\");\r\n/**\r\n * An internal data structure that tracks all the state being built up by the various\r\n * parser stages.\r\n */\r\nvar ParserContext = /** @class */ (function () {\r\n    function ParserContext(configuration, sourceRange) {\r\n        /**\r\n         * The text range starting from the opening `/**` and ending with\r\n         * the closing `*\\/` delimiter.\r\n         */\r\n        this.commentRange = TextRange_1.TextRange.empty;\r\n        /**\r\n         * The text ranges corresponding to the lines of content inside the comment.\r\n         */\r\n        this.lines = [];\r\n        /**\r\n         * A complete list of all tokens that were extracted from the input lines.\r\n         */\r\n        this.tokens = [];\r\n        this.configuration = configuration;\r\n        this.sourceRange = sourceRange;\r\n        this.docComment = new nodes_1.DocComment({ parserContext: this });\r\n        this.log = new ParserMessageLog_1.ParserMessageLog();\r\n    }\r\n    return ParserContext;\r\n}());\r\nexports.ParserContext = ParserContext;\r\n//# sourceMappingURL=ParserContext.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents an error or warning that occurred during parsing.\r\n */\r\nvar ParserMessage = /** @class */ (function () {\r\n    function ParserMessage(parameters) {\r\n        this.unformattedText = parameters.messageText;\r\n        this.textRange = parameters.textRange;\r\n        this.tokenSequence = parameters.tokenSequence;\r\n        this.docNode = parameters.docNode;\r\n        this._text = undefined;\r\n    }\r\n    /**\r\n     * Generates a line/column prefix.  Example with line=2 and column=5\r\n     * and message=\"An error occurred\":\r\n     * ```\r\n     * \"(2,5): An error occurred\"\r\n     * ```\r\n     */\r\n    ParserMessage._formatMessageText = function (message, range) {\r\n        if (!message) {\r\n            message = 'An unknown error occurred';\r\n        }\r\n        if (range.pos !== 0 || range.end !== 0) {\r\n            // NOTE: This currently a potentially expensive operation, since TSDoc currently doesn't\r\n            // have a full newline analysis for the input buffer.\r\n            var location = range.getLocation(range.pos);\r\n            if (location.line) {\r\n                return \"(\" + location.line + \",\" + location.column + \"): \" + message;\r\n            }\r\n        }\r\n        return message;\r\n    };\r\n    Object.defineProperty(ParserMessage.prototype, \"text\", {\r\n        /**\r\n         * The message text.\r\n         */\r\n        get: function () {\r\n            if (this._text === undefined) {\r\n                // NOTE: This currently a potentially expensive operation, since TSDoc currently doesn't\r\n                // have a full newline analysis for the input buffer.\r\n                this._text = ParserMessage._formatMessageText(this.unformattedText, this.textRange);\r\n            }\r\n            return this._text;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ParserMessage.prototype.toString = function () {\r\n        return this.text;\r\n    };\r\n    return ParserMessage;\r\n}());\r\nexports.ParserMessage = ParserMessage;\r\n//# sourceMappingURL=ParserMessage.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParserMessage_1 = require(\"./ParserMessage\");\r\n/**\r\n * Used to report errors and warnings that occurred during parsing.\r\n */\r\nvar ParserMessageLog = /** @class */ (function () {\r\n    function ParserMessageLog() {\r\n        this._messages = [];\r\n    }\r\n    Object.defineProperty(ParserMessageLog.prototype, \"messages\", {\r\n        /**\r\n         * The unfiltered list of all messages.\r\n         */\r\n        get: function () {\r\n            return this._messages;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Append a message to the log.\r\n     */\r\n    ParserMessageLog.prototype.addMessage = function (parserMessage) {\r\n        this._messages.push(parserMessage);\r\n    };\r\n    /**\r\n     * Append a message associated with a TextRange.\r\n     */\r\n    ParserMessageLog.prototype.addMessageForTextRange = function (messageText, textRange) {\r\n        this.addMessage(new ParserMessage_1.ParserMessage({\r\n            messageText: messageText,\r\n            textRange: textRange\r\n        }));\r\n    };\r\n    /**\r\n     * Append a message associated with a TokenSequence.\r\n     */\r\n    ParserMessageLog.prototype.addMessageForTokenSequence = function (messageText, tokenSequence, docNode) {\r\n        this.addMessage(new ParserMessage_1.ParserMessage({\r\n            messageText: messageText,\r\n            textRange: tokenSequence.getContainingTextRange(),\r\n            tokenSequence: tokenSequence,\r\n            docNode: docNode\r\n        }));\r\n    };\r\n    /**\r\n     * Append a message associated with a TokenSequence.\r\n     */\r\n    ParserMessageLog.prototype.addMessageForDocErrorText = function (docErrorText) {\r\n        var tokenSequence;\r\n        if (docErrorText.excerpt) {\r\n            // If there is an excerpt directly associated with the DocErrorText, highlight that:\r\n            tokenSequence = docErrorText.excerpt.content;\r\n        }\r\n        else {\r\n            // Otherwise we can use the errorLocation, but typically that is meant to give additional\r\n            // details, not to indicate the primary location of the problem.\r\n            tokenSequence = docErrorText.errorLocation;\r\n        }\r\n        this.addMessage(new ParserMessage_1.ParserMessage({\r\n            messageText: docErrorText.errorMessage,\r\n            textRange: tokenSequence.getContainingTextRange(),\r\n            tokenSequence: tokenSequence,\r\n            docNode: docErrorText\r\n        }));\r\n    };\r\n    return ParserMessageLog;\r\n}());\r\nexports.ParserMessageLog = ParserMessageLog;\r\n//# sourceMappingURL=ParserMessageLog.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Helpers for validating various text string formats.\r\n */\r\nvar StringChecks = /** @class */ (function () {\r\n    function StringChecks() {\r\n    }\r\n    /**\r\n     * Tests whether the input string is a valid TSDoc tag name; if not, returns an error message.\r\n     * TSDoc tag names start with an at-sign (\"@\") followed by ASCII letters using\r\n     * \"camelCase\" capitalization.\r\n     */\r\n    StringChecks.explainIfInvalidTSDocTagName = function (tagName) {\r\n        if (tagName[0] !== '@') {\r\n            return 'A TSDoc tag name must start with an \"@\" symbol';\r\n        }\r\n        if (!StringChecks._tsdocTagNameRegExp.test(tagName)) {\r\n            return 'A TSDoc tag name must start with a letter and contain only letters and numbers';\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Throws an exception if the input string is not a valid TSDoc tag name.\r\n     * TSDoc tag names start with an at-sign (\"@\") followed by ASCII letters using\r\n     * \"camelCase\" capitalization.\r\n     */\r\n    StringChecks.validateTSDocTagName = function (tagName) {\r\n        var explanation = StringChecks.explainIfInvalidTSDocTagName(tagName);\r\n        if (explanation) {\r\n            throw new Error(explanation);\r\n        }\r\n    };\r\n    /**\r\n     * Tests whether the input string is a URL form supported inside an \"@link\" tag; if not,\r\n     * returns an error message.\r\n     */\r\n    StringChecks.explainIfInvalidLinkUrl = function (url) {\r\n        if (url.length === 0) {\r\n            return 'The URL cannot be empty';\r\n        }\r\n        if (!StringChecks._urlSchemeRegExp.test(url)) {\r\n            return 'An @link URL must begin with a scheme comprised only of letters and numbers followed by \"://\".'\r\n                + ' (For general URLs, use an HTML \"<a>\" tag instead.)';\r\n        }\r\n        if (!StringChecks._urlSchemeAfterRegExp.test(url)) {\r\n            return 'An @link URL must have at least one character after \"://\"';\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Tests whether the input string is a valid NPM package name.\r\n     */\r\n    StringChecks.explainIfInvalidPackageName = function (packageName) {\r\n        if (packageName.length === 0) {\r\n            return 'The package name cannot be an empty string';\r\n        }\r\n        if (!StringChecks._validPackageNameRegExp.test(packageName)) {\r\n            return \"The package name \" + JSON.stringify(packageName) + \" is not a valid package name\";\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Tests whether the input string is a valid declaration reference import path.\r\n     */\r\n    StringChecks.explainIfInvalidImportPath = function (importPath, prefixedByPackageName) {\r\n        if (importPath.length > 0) {\r\n            if (importPath.indexOf('//') >= 0) {\r\n                return 'An import path must not contain \"//\"';\r\n            }\r\n            if (importPath[importPath.length - 1] === '/') {\r\n                return 'An import path must not end with \"/\"';\r\n            }\r\n            if (!prefixedByPackageName) {\r\n                if (importPath[0] === '/') {\r\n                    return 'An import path must not start with \"/\" unless prefixed by a package name';\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns true if the input string is a TSDoc system selector.\r\n     */\r\n    StringChecks.isSystemSelector = function (selector) {\r\n        return StringChecks._systemSelectors.has(selector);\r\n    };\r\n    /**\r\n     * Tests whether the input string is a valid ECMAScript identifier.\r\n     * A precise check is extremely complicated and highly dependent on the standard version\r\n     * and how faithfully the interpreter implements it, so here we use a conservative heuristic.\r\n     */\r\n    StringChecks.explainIfInvalidUnquotedIdentifier = function (identifier) {\r\n        if (identifier.length === 0) {\r\n            return 'The identifier cannot be an empty string';\r\n        }\r\n        if (StringChecks._identifierNotWordCharRegExp.test(identifier)) {\r\n            return 'The identifier cannot non-word characters';\r\n        }\r\n        if (StringChecks._identifierNumberStartRegExp.test(identifier)) {\r\n            return 'The identifier must not start with a number';\r\n        }\r\n        if (StringChecks.isSystemSelector(identifier)) {\r\n            // We do this to avoid confusion about the declaration reference syntax rules.\r\n            // For example if someone were to see \"MyClass.(static:instance)\" it would be unclear which\r\n            // side the colon is the selector.\r\n            return \"The identifier \\\"\" + identifier + \"\\\" must be quoted because it is a TSDoc system selector name\";\r\n        }\r\n        return undefined;\r\n    };\r\n    StringChecks._tsdocTagNameRegExp = /^@[a-z][a-z0-9]*$/i;\r\n    StringChecks._urlSchemeRegExp = /^[a-z][a-z0-9]*\\:\\/\\//i;\r\n    StringChecks._urlSchemeAfterRegExp = /^[a-z][a-z0-9]*\\:\\/\\/./i;\r\n    StringChecks._identifierNotWordCharRegExp = /\\W/u;\r\n    StringChecks._identifierNumberStartRegExp = /^[0-9]/u;\r\n    StringChecks._validPackageNameRegExp = /^(?:@[a-z0-9\\-_\\.]+\\/)?[a-z0-9\\-_\\.]+$/i;\r\n    StringChecks._systemSelectors = new Set([\r\n        // For classes:\r\n        'instance', 'static', 'constructor',\r\n        // For merged declarations:\r\n        'class', 'enum', 'function', 'interface', 'namespace', 'type', 'variable'\r\n    ]);\r\n    return StringChecks;\r\n}());\r\nexports.StringChecks = StringChecks;\r\n//# sourceMappingURL=StringChecks.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TextRange_1 = require(\"./TextRange\");\r\nvar ParserContext_1 = require(\"./ParserContext\");\r\nvar LineExtractor_1 = require(\"./LineExtractor\");\r\nvar Tokenizer_1 = require(\"./Tokenizer\");\r\nvar NodeParser_1 = require(\"./NodeParser\");\r\nvar TSDocParserConfiguration_1 = require(\"./TSDocParserConfiguration\");\r\nvar ParagraphSplitter_1 = require(\"./ParagraphSplitter\");\r\n/**\r\n * The main API for parsing TSDoc comments.\r\n */\r\nvar TSDocParser = /** @class */ (function () {\r\n    function TSDocParser(configuration) {\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n        }\r\n        else {\r\n            this.configuration = new TSDocParserConfiguration_1.TSDocParserConfiguration();\r\n        }\r\n    }\r\n    TSDocParser.prototype.parseString = function (text) {\r\n        return this.parseRange(TextRange_1.TextRange.fromString(text));\r\n    };\r\n    TSDocParser.prototype.parseRange = function (range) {\r\n        var parserContext = new ParserContext_1.ParserContext(this.configuration, range);\r\n        if (LineExtractor_1.LineExtractor.extract(parserContext)) {\r\n            parserContext.tokens = Tokenizer_1.Tokenizer.readTokens(parserContext.lines);\r\n            var nodeParser = new NodeParser_1.NodeParser(parserContext);\r\n            nodeParser.parse();\r\n            ParagraphSplitter_1.ParagraphSplitter.splitParagraphs(parserContext.docComment);\r\n        }\r\n        return parserContext;\r\n    };\r\n    return TSDocParser;\r\n}());\r\nexports.TSDocParser = TSDocParser;\r\n//# sourceMappingURL=TSDocParser.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StandardTags_1 = require(\"../details/StandardTags\");\r\n/**\r\n * Part of the {@link TSDocParserConfiguration} object.\r\n */\r\nvar TSDocParserValidationConfiguration = /** @class */ (function () {\r\n    function TSDocParserValidationConfiguration() {\r\n        /**\r\n         * Set `ignoreUndefinedTags` to true to silently ignore unrecognized tags,\r\n         * instead of reporting a warning.\r\n         *\r\n         * @remarks\r\n         * Normally the parser will issue errors when it encounters tag names that do not\r\n         * have a corresponding definition in {@link TSDocParserConfiguration.tagDefinitions}.\r\n         * This helps to catch common mistakes such as a misspelled tag.\r\n         *\r\n         * @defaultValue `false`\r\n         */\r\n        this.ignoreUndefinedTags = false;\r\n        /**\r\n         * Set `reportUnsupportedTags` to true to issue a warning for tags that are not\r\n         * supported by your tool.\r\n         *\r\n         * @remarks\r\n         * The TSDoc standard defines may tags.  By default it assumes that if your tool does\r\n         * not implement one of these tags, then it will simply ignore it.  But sometimes this\r\n         * may be misleading for developers. (For example, they might write an `@example` block\r\n         * and then be surprised if it doesn't appear in the documentation output.).\r\n         *\r\n         * For a better experience, you can tell the parser which tags you support, and then it\r\n         * will issue warnings wherever unsupported tags are used.  This is done using\r\n         * {@link TSDocParserConfiguration.setSupportForTag}.  Note that calling that function\r\n         * automatically sets `reportUnsupportedTags` to true.\r\n         *\r\n         * @defaultValue `false`\r\n         */\r\n        this.reportUnsupportedTags = false;\r\n    }\r\n    return TSDocParserValidationConfiguration;\r\n}());\r\nexports.TSDocParserValidationConfiguration = TSDocParserValidationConfiguration;\r\n/**\r\n * Configuration for the TSDocParser.\r\n */\r\nvar TSDocParserConfiguration = /** @class */ (function () {\r\n    function TSDocParserConfiguration() {\r\n        this._tagDefinitions = [];\r\n        this._tagDefinitionsByName = new Map();\r\n        this._supportedTagDefinitions = new Set();\r\n        this._validation = new TSDocParserValidationConfiguration();\r\n        // Define all the standard tags\r\n        this.addTagDefinitions(StandardTags_1.StandardTags.allDefinitions);\r\n    }\r\n    Object.defineProperty(TSDocParserConfiguration.prototype, \"tagDefinitions\", {\r\n        /**\r\n         * The TSDoc block tag names that will be interpreted as modifier tags.\r\n         */\r\n        get: function () {\r\n            return this._tagDefinitions;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TSDocParserConfiguration.prototype, \"supportedTagDefinitions\", {\r\n        /**\r\n         * Returns the subset of {@link TSDocParserConfiguration.tagDefinitions}\r\n         * that are supported in this configuration.\r\n         *\r\n         * @remarks\r\n         * This property is only used when\r\n         * {@link TSDocParserValidationConfiguration.reportUnsupportedTags} is enabled.\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            return this.tagDefinitions.filter(function (x) { return _this.isTagSupported(x); });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TSDocParserConfiguration.prototype, \"validation\", {\r\n        /**\r\n         * Enable/disable validation checks performed by the parser.\r\n         */\r\n        get: function () {\r\n            return this._validation;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Return the tag that was defined with the specified name, or undefined\r\n     * if not found.\r\n     */\r\n    TSDocParserConfiguration.prototype.tryGetTagDefinition = function (tagName) {\r\n        return this._tagDefinitionsByName.get(tagName.toUpperCase());\r\n    };\r\n    /**\r\n     * Return the tag that was defined with the specified name, or undefined\r\n     * if not found.\r\n     */\r\n    TSDocParserConfiguration.prototype.tryGetTagDefinitionWithUpperCase = function (alreadyUpperCaseTagName) {\r\n        return this._tagDefinitionsByName.get(alreadyUpperCaseTagName);\r\n    };\r\n    /**\r\n     * Define a new TSDoc tag to be recognized by the TSDocParser, and mark it as unsupported.\r\n     * Use {@link TSDocParserConfiguration.setSupportForTag} to mark it as supported.\r\n     *\r\n     * @remarks\r\n     * If a tag is \"defined\" this means that the parser recognizes it and understands its syntax.\r\n     * Whereas if a tag is \"supported\", this means it is defined AND the application implements the tag.\r\n     */\r\n    TSDocParserConfiguration.prototype.addTagDefinition = function (tagDefinition) {\r\n        var existingDefinition = this._tagDefinitionsByName.get(tagDefinition.tagNameWithUpperCase);\r\n        if (existingDefinition === tagDefinition) {\r\n            return;\r\n        }\r\n        if (existingDefinition) {\r\n            throw new Error(\"A tag is already defined using the name \" + existingDefinition.tagName);\r\n        }\r\n        this._tagDefinitions.push(tagDefinition);\r\n        this._tagDefinitionsByName.set(tagDefinition.tagNameWithUpperCase, tagDefinition);\r\n    };\r\n    /**\r\n     * Calls {@link TSDocParserConfiguration.addTagDefinition} for a list of definitions,\r\n     * and optionally marks them as supported.\r\n     * @param tagDefinitions - the definitions to be added\r\n     * @param supported - if specified, calls the {@link TSDocParserConfiguration.setSupportForTag}\r\n     *    method to mark the definitions as supported or unsupported\r\n     */\r\n    TSDocParserConfiguration.prototype.addTagDefinitions = function (tagDefinitions, supported) {\r\n        for (var _i = 0, tagDefinitions_1 = tagDefinitions; _i < tagDefinitions_1.length; _i++) {\r\n            var tagDefinition = tagDefinitions_1[_i];\r\n            this.addTagDefinition(tagDefinition);\r\n            if (supported !== undefined) {\r\n                this.setSupportForTag(tagDefinition, supported);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if the tag is supported in this configuration.\r\n     */\r\n    TSDocParserConfiguration.prototype.isTagSupported = function (tagDefinition) {\r\n        this._requireTagToBeDefined(tagDefinition);\r\n        return this._supportedTagDefinitions.has(tagDefinition);\r\n    };\r\n    /**\r\n     * Specifies whether the tag definition is supported in this configuration.\r\n     * The parser may issue warnings for unsupported tags.\r\n     *\r\n     * @remarks\r\n     * If a tag is \"defined\" this means that the parser recognizes it and understands its syntax.\r\n     * Whereas if a tag is \"supported\", this means it is defined AND the application implements the tag.\r\n     *\r\n     * This function automatically sets {@link TSDocParserValidationConfiguration.reportUnsupportedTags}\r\n     * to true.\r\n     */\r\n    TSDocParserConfiguration.prototype.setSupportForTag = function (tagDefinition, supported) {\r\n        this._requireTagToBeDefined(tagDefinition);\r\n        if (supported) {\r\n            this._supportedTagDefinitions.add(tagDefinition);\r\n        }\r\n        else {\r\n            this._supportedTagDefinitions.delete(tagDefinition);\r\n        }\r\n        this.validation.reportUnsupportedTags = true;\r\n    };\r\n    /**\r\n     * Calls {@link TSDocParserConfiguration.setSupportForTag} for multiple tag definitions.\r\n     */\r\n    TSDocParserConfiguration.prototype.setSupportForTags = function (tagDefinitions, supported) {\r\n        for (var _i = 0, tagDefinitions_2 = tagDefinitions; _i < tagDefinitions_2.length; _i++) {\r\n            var tagDefinition = tagDefinitions_2[_i];\r\n            this.setSupportForTag(tagDefinition, supported);\r\n        }\r\n    };\r\n    TSDocParserConfiguration.prototype._requireTagToBeDefined = function (tagDefinition) {\r\n        var matching = this._tagDefinitionsByName.get(tagDefinition.tagNameWithUpperCase);\r\n        if (matching) {\r\n            if (matching === tagDefinition) {\r\n                return;\r\n            }\r\n        }\r\n        throw new Error('The specified TSDocTagDefinition is not defined for this TSDocParserConfiguration');\r\n    };\r\n    return TSDocParserConfiguration;\r\n}());\r\nexports.TSDocParserConfiguration = TSDocParserConfiguration;\r\n//# sourceMappingURL=TSDocParserConfiguration.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StringChecks_1 = require(\"./StringChecks\");\r\n/**\r\n * Determines the type of syntax for a TSDocTagDefinition\r\n */\r\nvar TSDocTagSyntaxKind;\r\n(function (TSDocTagSyntaxKind) {\r\n    /**\r\n     * The tag is intended to be an inline tag.  For example: `{@link}`.\r\n     */\r\n    TSDocTagSyntaxKind[TSDocTagSyntaxKind[\"InlineTag\"] = 0] = \"InlineTag\";\r\n    /**\r\n     * The tag is intended to be a block tag that starts a new documentation\r\n     * section.  For example: `@remarks`\r\n     */\r\n    TSDocTagSyntaxKind[TSDocTagSyntaxKind[\"BlockTag\"] = 1] = \"BlockTag\";\r\n    /**\r\n     * The tag is intended to be a modifier tag whose presences indicates\r\n     * an aspect of the associated API item.  For example: `@internal`\r\n     */\r\n    TSDocTagSyntaxKind[TSDocTagSyntaxKind[\"ModifierTag\"] = 2] = \"ModifierTag\";\r\n})(TSDocTagSyntaxKind = exports.TSDocTagSyntaxKind || (exports.TSDocTagSyntaxKind = {}));\r\n/**\r\n * Defines a TSDoc tag that will be understood by the TSDocParser.\r\n */\r\nvar TSDocTagDefinition = /** @class */ (function () {\r\n    function TSDocTagDefinition(parameters) {\r\n        StringChecks_1.StringChecks.validateTSDocTagName(parameters.tagName);\r\n        this.tagName = parameters.tagName;\r\n        this.tagNameWithUpperCase = parameters.tagName.toUpperCase();\r\n        this.syntaxKind = parameters.syntaxKind;\r\n        this.standardization = parameters.standardization\r\n            || \"None\" /* None */;\r\n        this.allowMultiple = !!parameters.allowMultiple;\r\n    }\r\n    return TSDocTagDefinition;\r\n}());\r\nexports.TSDocTagDefinition = TSDocTagDefinition;\r\n//# sourceMappingURL=TSDocTagDefinition.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Efficiently references a range of text from a string buffer.\r\n */\r\nvar TextRange = /** @class */ (function () {\r\n    function TextRange(buffer, pos, end) {\r\n        this.buffer = buffer;\r\n        this.pos = pos;\r\n        this.end = end;\r\n        this._validateBounds();\r\n    }\r\n    /**\r\n     * Constructs a TextRange that corresponds to an entire string object.\r\n     */\r\n    TextRange.fromString = function (buffer) {\r\n        return new TextRange(buffer, 0, buffer.length);\r\n    };\r\n    /**\r\n     * Constructs a TextRange that corresponds to an entire string object.\r\n     */\r\n    TextRange.fromStringRange = function (buffer, pos, end) {\r\n        return new TextRange(buffer, pos, end);\r\n    };\r\n    /**\r\n     * Constructs a TextRange that corresponds to a different range of an existing buffer.\r\n     */\r\n    TextRange.prototype.getNewRange = function (pos, end) {\r\n        return new TextRange(this.buffer, pos, end);\r\n    };\r\n    /**\r\n     * Returns true if the length of the range is zero.  Note that the object reference may not\r\n     * be equal to `TextRange.empty`, and the buffer may be different.\r\n     */\r\n    TextRange.prototype.isEmpty = function () {\r\n        return this.pos === this.end;\r\n    };\r\n    /**\r\n     * Returns the range from the associated string buffer.\r\n     */\r\n    TextRange.prototype.toString = function () {\r\n        return this.buffer.substring(this.pos, this.end);\r\n    };\r\n    /**\r\n     * Returns a debugging dump of the range, indicated via custom delimiters.\r\n     * @remarks\r\n     * For example if the delimiters are \"[\" and \"]\", and the range is 3..5 inside \"1234567\",\r\n     * then the output would be \"12[345]67\".\r\n     */\r\n    TextRange.prototype.getDebugDump = function (posDelimiter, endDelimiter) {\r\n        return this.buffer.substring(0, this.pos)\r\n            + posDelimiter\r\n            + this.buffer.substring(this.pos, this.end)\r\n            + endDelimiter\r\n            + this.buffer.substring(this.end);\r\n    };\r\n    /**\r\n     * Calculates the line and column number for the specified offset into the buffer.\r\n     *\r\n     * @remarks\r\n     * This is a potentially expensive operation.\r\n     *\r\n     * @param index - an integer offset\r\n     * @param buffer - the buffer\r\n     */\r\n    TextRange.prototype.getLocation = function (index) {\r\n        if (index < 0 || index > this.buffer.length) {\r\n            // No match\r\n            return { line: 0, column: 0 };\r\n        }\r\n        // TODO: Consider caching or optimizing this somehow\r\n        var line = 1;\r\n        var column = 1;\r\n        var currentIndex = 0;\r\n        while (currentIndex < index) {\r\n            var current = this.buffer[currentIndex];\r\n            ++currentIndex;\r\n            if (current === '\\r') { // CR\r\n                // Ignore '\\r' and assume it will always have an accompanying '\\n'\r\n                continue;\r\n            }\r\n            if (current === '\\n') { // LF\r\n                ++line;\r\n                column = 1;\r\n            }\r\n            else {\r\n                // NOTE: For consistency with the TypeScript compiler, a tab character is assumed\r\n                // to advance by one column\r\n                ++column;\r\n            }\r\n        }\r\n        return { line: line, column: column };\r\n    };\r\n    TextRange.prototype._validateBounds = function () {\r\n        if (this.pos < 0) {\r\n            throw new Error('TextRange.pos cannot be negative');\r\n        }\r\n        if (this.end < 0) {\r\n            throw new Error('TextRange.end cannot be negative');\r\n        }\r\n        if (this.end < this.pos) {\r\n            throw new Error('TextRange.end cannot be smaller than TextRange.pos');\r\n        }\r\n        if (this.pos > this.buffer.length) {\r\n            throw new Error('TextRange.pos cannot exceed the associated text buffer length');\r\n        }\r\n        if (this.end > this.buffer.length) {\r\n            throw new Error('TextRange.end cannot exceed the associated text buffer length');\r\n        }\r\n    };\r\n    /**\r\n     * Used to represent an empty or unknown range.\r\n     */\r\n    TextRange.empty = new TextRange('', 0, 0);\r\n    return TextRange;\r\n}());\r\nexports.TextRange = TextRange;\r\n//# sourceMappingURL=TextRange.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Distinguishes different types of Token objects.\r\n */\r\nvar TokenKind;\r\n(function (TokenKind) {\r\n    /**\r\n     * A token representing the end of the input.  The Token.range will be an empty range\r\n     * at the end of the provided input.\r\n     */\r\n    TokenKind[TokenKind[\"EndOfInput\"] = 2001] = \"EndOfInput\";\r\n    /**\r\n     * A token representing a virtual newline.\r\n     * The Token.range will be an empty range, because the actual newline character may\r\n     * be noncontiguous due to the doc comment delimiter trimming.\r\n     */\r\n    TokenKind[TokenKind[\"Newline\"] = 2002] = \"Newline\";\r\n    /**\r\n     * A token representing one or more spaces and tabs (but not newlines or end of input).\r\n     */\r\n    TokenKind[TokenKind[\"Spacing\"] = 2003] = \"Spacing\";\r\n    /**\r\n     * A token representing one or more ASCII letters, numbers, and underscores.\r\n     */\r\n    TokenKind[TokenKind[\"AsciiWord\"] = 2004] = \"AsciiWord\";\r\n    /**\r\n     * A single ASCII character that behaves like punctuation, e.g. doesn't need whitespace\r\n     * around it when adjacent to a letter.  The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"OtherPunctuation\"] = 2005] = \"OtherPunctuation\";\r\n    /**\r\n     * A token representing a sequence of non-ASCII printable characters that are not punctuation.\r\n     */\r\n    TokenKind[TokenKind[\"Other\"] = 2006] = \"Other\";\r\n    /**\r\n     * The backslash character `\\`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Backslash\"] = 2007] = \"Backslash\";\r\n    /**\r\n     * The less-than character `<`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"LessThan\"] = 2008] = \"LessThan\";\r\n    /**\r\n     * The greater-than character `>`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"GreaterThan\"] = 2009] = \"GreaterThan\";\r\n    /**\r\n     * The equals character `=`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Equals\"] = 2010] = \"Equals\";\r\n    /**\r\n     * The single-quote character `'`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"SingleQuote\"] = 2011] = \"SingleQuote\";\r\n    /**\r\n     * The double-quote character `\"`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"DoubleQuote\"] = 2012] = \"DoubleQuote\";\r\n    /**\r\n     * The slash character `/`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Slash\"] = 2013] = \"Slash\";\r\n    /**\r\n     * The hyphen character `-`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Hyphen\"] = 2014] = \"Hyphen\";\r\n    /**\r\n     * The at-sign character `@`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"AtSign\"] = 2015] = \"AtSign\";\r\n    /**\r\n     * The left curly bracket character `{`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"LeftCurlyBracket\"] = 2016] = \"LeftCurlyBracket\";\r\n    /**\r\n     * The right curly bracket character `}`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"RightCurlyBracket\"] = 2017] = \"RightCurlyBracket\";\r\n    /**\r\n     * The backtick character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Backtick\"] = 2018] = \"Backtick\";\r\n    /**\r\n     * The period character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Period\"] = 2019] = \"Period\";\r\n    /**\r\n     * The colon character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Colon\"] = 2020] = \"Colon\";\r\n    /**\r\n     * The comma character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Comma\"] = 2021] = \"Comma\";\r\n    /**\r\n     * The left square bracket character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"LeftSquareBracket\"] = 2022] = \"LeftSquareBracket\";\r\n    /**\r\n     * The right square bracket character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"RightSquareBracket\"] = 2023] = \"RightSquareBracket\";\r\n    /**\r\n     * The pipe character `|`.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Pipe\"] = 2024] = \"Pipe\";\r\n    /**\r\n     * The left parenthesis character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"LeftParenthesis\"] = 2025] = \"LeftParenthesis\";\r\n    /**\r\n     * The right parenthesis character.\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"RightParenthesis\"] = 2026] = \"RightParenthesis\";\r\n    /**\r\n     * The pound character (\"#\").\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"PoundSymbol\"] = 2027] = \"PoundSymbol\";\r\n    /**\r\n     * The plus character (\"+\").\r\n     * The Token.range will always be a string of length 1.\r\n     */\r\n    TokenKind[TokenKind[\"Plus\"] = 2028] = \"Plus\";\r\n})(TokenKind = exports.TokenKind || (exports.TokenKind = {}));\r\n/**\r\n * Represents a contiguous range of characters extracted from one of the doc comment lines\r\n * being processed by the Tokenizer.  There is a token representing a newline, but otherwise\r\n * a single token cannot span multiple lines.\r\n */\r\nvar Token = /** @class */ (function () {\r\n    function Token(kind, range, line) {\r\n        this.kind = kind;\r\n        this.range = range;\r\n        this.line = line;\r\n    }\r\n    Token.prototype.toString = function () {\r\n        if (this.kind === TokenKind.Newline) {\r\n            return '\\n';\r\n        }\r\n        return this.range.toString();\r\n    };\r\n    return Token;\r\n}());\r\nexports.Token = Token;\r\n//# sourceMappingURL=Token.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Token_1 = require(\"./Token\");\r\nvar TokenSequence_1 = require(\"./TokenSequence\");\r\n/**\r\n * Manages a stream of tokens that are read by the parser.\r\n *\r\n * @remarks\r\n * Use TokenReader.readToken() to read a token and advance the stream pointer.\r\n * Use TokenReader.peekToken() to preview the next token.\r\n * Use TokenReader.createMarker() and backtrackToMarker() to rewind to an earlier point.\r\n * Whenever readToken() is called, the token is added to an accumulated TokenSequence\r\n * that can be extracted by calling extractAccumulatedSequence().\r\n */\r\nvar TokenReader = /** @class */ (function () {\r\n    function TokenReader(parserContext, embeddedTokenSequence) {\r\n        this._parserContext = parserContext;\r\n        this.tokens = parserContext.tokens;\r\n        if (embeddedTokenSequence) {\r\n            if (embeddedTokenSequence.parserContext !== this._parserContext) {\r\n                throw new Error('The embeddedTokenSequence must use the same parser context');\r\n            }\r\n            this._readerStartIndex = embeddedTokenSequence.startIndex;\r\n            this._readerEndIndex = embeddedTokenSequence.endIndex;\r\n        }\r\n        else {\r\n            this._readerStartIndex = 0;\r\n            this._readerEndIndex = this.tokens.length;\r\n        }\r\n        this._currentIndex = this._readerStartIndex;\r\n        this._accumulatedStartIndex = this._readerStartIndex;\r\n    }\r\n    /**\r\n     * Extracts and returns the TokenSequence that was accumulated so far by calls to readToken().\r\n     * The next call to readToken() will start a new accumulated sequence.\r\n     */\r\n    TokenReader.prototype.extractAccumulatedSequence = function () {\r\n        if (this._accumulatedStartIndex === this._currentIndex) {\r\n            // If this happens, it indicates a parser bug:\r\n            throw new Error('Parser assertion failed: The queue should not be empty when'\r\n                + ' extractAccumulatedSequence() is called');\r\n        }\r\n        var sequence = new TokenSequence_1.TokenSequence({\r\n            parserContext: this._parserContext,\r\n            startIndex: this._accumulatedStartIndex,\r\n            endIndex: this._currentIndex\r\n        });\r\n        this._accumulatedStartIndex = this._currentIndex;\r\n        return sequence;\r\n    };\r\n    /**\r\n     * Returns true if the accumulated sequence has any tokens yet.  This will be false\r\n     * when the TokenReader starts, and it will be false immediately after a call\r\n     * to extractAccumulatedSequence().  Otherwise, it will become true whenever readToken()\r\n     * is called.\r\n     */\r\n    TokenReader.prototype.isAccumulatedSequenceEmpty = function () {\r\n        return this._accumulatedStartIndex === this._currentIndex;\r\n    };\r\n    /**\r\n     * Like extractAccumulatedSequence(), but returns undefined if nothing has been\r\n     * accumulated yet.\r\n     */\r\n    TokenReader.prototype.tryExtractAccumulatedSequence = function () {\r\n        if (this.isAccumulatedSequenceEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.extractAccumulatedSequence();\r\n    };\r\n    /**\r\n     * Asserts that isAccumulatedSequenceEmpty() should return false.  If not, an exception\r\n     * is throw indicating a parser bug.\r\n     */\r\n    TokenReader.prototype.assertAccumulatedSequenceIsEmpty = function () {\r\n        if (!this.isAccumulatedSequenceEmpty()) {\r\n            // If this happens, it indicates a parser bug:\r\n            var sequence = new TokenSequence_1.TokenSequence({\r\n                parserContext: this._parserContext,\r\n                startIndex: this._accumulatedStartIndex,\r\n                endIndex: this._currentIndex\r\n            });\r\n            var tokenStrings = sequence.tokens.map(function (x) { return x.toString(); });\r\n            throw new Error('Parser assertion failed: The queue should be empty, but it contains:\\n'\r\n                + JSON.stringify(tokenStrings));\r\n        }\r\n    };\r\n    /**\r\n     * Returns the next token that would be returned by _readToken(), without\r\n     * consuming anything.\r\n     */\r\n    TokenReader.prototype.peekToken = function () {\r\n        return this.tokens[this._currentIndex];\r\n    };\r\n    /**\r\n     * Returns the TokenKind for the next token that would be returned by _readToken(), without\r\n     * consuming anything.\r\n     */\r\n    TokenReader.prototype.peekTokenKind = function () {\r\n        if (this._currentIndex >= this._readerEndIndex) {\r\n            return Token_1.TokenKind.EndOfInput;\r\n        }\r\n        return this.tokens[this._currentIndex].kind;\r\n    };\r\n    /**\r\n     * Like peekTokenKind(), but looks ahead two tokens.\r\n     */\r\n    TokenReader.prototype.peekTokenAfterKind = function () {\r\n        if (this._currentIndex + 1 >= this._readerEndIndex) {\r\n            return Token_1.TokenKind.EndOfInput;\r\n        }\r\n        return this.tokens[this._currentIndex + 1].kind;\r\n    };\r\n    /**\r\n     * Like peekTokenKind(), but looks ahead three tokens.\r\n     */\r\n    TokenReader.prototype.peekTokenAfterAfterKind = function () {\r\n        if (this._currentIndex + 2 >= this._readerEndIndex) {\r\n            return Token_1.TokenKind.EndOfInput;\r\n        }\r\n        return this.tokens[this._currentIndex + 2].kind;\r\n    };\r\n    /**\r\n     * Extract the next token from the input stream and return it.\r\n     * The token will also be appended to the accumulated sequence, which can\r\n     * later be accessed via extractAccumulatedSequence().\r\n     */\r\n    TokenReader.prototype.readToken = function () {\r\n        if (this._currentIndex >= this._readerEndIndex) {\r\n            // If this happens, it's a parser bug\r\n            throw new Error('Cannot read past end of stream');\r\n        }\r\n        var token = this.tokens[this._currentIndex];\r\n        if (token.kind === Token_1.TokenKind.EndOfInput) {\r\n            // We don't allow reading the EndOfInput token, because we want _peekToken()\r\n            // to be always guaranteed to return a valid result.\r\n            // If this happens, it's a parser bug\r\n            throw new Error('The EndOfInput token cannot be read');\r\n        }\r\n        this._currentIndex++;\r\n        return token;\r\n    };\r\n    /**\r\n     * Returns the kind of the token immediately before the current token.\r\n     */\r\n    TokenReader.prototype.peekPreviousTokenKind = function () {\r\n        if (this._currentIndex === 0) {\r\n            return Token_1.TokenKind.EndOfInput;\r\n        }\r\n        return this.tokens[this._currentIndex - 1].kind;\r\n    };\r\n    /**\r\n     * Remembers the current position in the stream.\r\n     */\r\n    TokenReader.prototype.createMarker = function () {\r\n        return this._currentIndex;\r\n    };\r\n    /**\r\n     * Rewinds the stream pointer to a previous position in the stream.\r\n     */\r\n    TokenReader.prototype.backtrackToMarker = function (marker) {\r\n        if (marker > this._currentIndex) {\r\n            // If this happens, it's a parser bug\r\n            throw new Error('The marker has expired');\r\n        }\r\n        this._currentIndex = marker;\r\n        if (marker < this._accumulatedStartIndex) {\r\n            this._accumulatedStartIndex = marker;\r\n        }\r\n    };\r\n    return TokenReader;\r\n}());\r\nexports.TokenReader = TokenReader;\r\n//# sourceMappingURL=TokenReader.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TextRange_1 = require(\"./TextRange\");\r\n/**\r\n * Represents a sequence of tokens extracted from `ParserContext.tokens`.\r\n * This sequence is defined by a starting index and ending index into that array.\r\n */\r\nvar TokenSequence = /** @class */ (function () {\r\n    function TokenSequence(parameters) {\r\n        this.parserContext = parameters.parserContext;\r\n        this._startIndex = parameters.startIndex;\r\n        this._endIndex = parameters.endIndex;\r\n        this._validateBounds();\r\n    }\r\n    /**\r\n     * Constructs a TokenSequence object with no tokens.\r\n     */\r\n    TokenSequence.createEmpty = function (parserContext) {\r\n        return new TokenSequence({ parserContext: parserContext, startIndex: 0, endIndex: 0 });\r\n    };\r\n    Object.defineProperty(TokenSequence.prototype, \"startIndex\", {\r\n        /**\r\n         * The starting index into the associated `ParserContext.tokens` list.\r\n         */\r\n        get: function () {\r\n            return this._startIndex;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TokenSequence.prototype, \"endIndex\", {\r\n        /**\r\n         * The (non-inclusive) ending index into the associated `ParserContext.tokens` list.\r\n         */\r\n        get: function () {\r\n            return this._endIndex;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TokenSequence.prototype, \"tokens\", {\r\n        get: function () {\r\n            return this.parserContext.tokens.slice(this._startIndex, this._endIndex);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Constructs a TokenSequence that corresponds to a different range of tokens,\r\n     * e.g. a subrange.\r\n     */\r\n    TokenSequence.prototype.getNewSequence = function (startIndex, endIndex) {\r\n        return new TokenSequence({\r\n            parserContext: this.parserContext,\r\n            startIndex: startIndex,\r\n            endIndex: endIndex\r\n        });\r\n    };\r\n    /**\r\n     * Returns a TextRange that includes all tokens in the sequence (including any additional\r\n     * characters between doc comment lines).\r\n     */\r\n    TokenSequence.prototype.getContainingTextRange = function () {\r\n        if (this.isEmpty()) {\r\n            return TextRange_1.TextRange.empty;\r\n        }\r\n        return this.parserContext.sourceRange.getNewRange(this.parserContext.tokens[this._startIndex].range.pos, this.parserContext.tokens[this._endIndex - 1].range.end);\r\n    };\r\n    TokenSequence.prototype.isEmpty = function () {\r\n        return this._startIndex === this._endIndex;\r\n    };\r\n    /**\r\n     * Returns the concatenated text of all the tokens.\r\n     */\r\n    TokenSequence.prototype.toString = function () {\r\n        return this.tokens.map(function (x) { return x.toString(); }).join('');\r\n    };\r\n    TokenSequence.prototype._validateBounds = function () {\r\n        if (this.startIndex < 0) {\r\n            throw new Error('TokenSequence.startIndex cannot be negative');\r\n        }\r\n        if (this.endIndex < 0) {\r\n            throw new Error('TokenSequence.endIndex cannot be negative');\r\n        }\r\n        if (this.endIndex < this.startIndex) {\r\n            throw new Error('TokenSequence.endIndex cannot be smaller than TokenSequence.startIndex');\r\n        }\r\n        if (this.startIndex > this.parserContext.tokens.length) {\r\n            throw new Error('TokenSequence.startIndex cannot exceed the associated token array');\r\n        }\r\n        if (this.endIndex > this.parserContext.tokens.length) {\r\n            throw new Error('TokenSequence.endIndex cannot exceed the associated token array');\r\n        }\r\n    };\r\n    return TokenSequence;\r\n}());\r\nexports.TokenSequence = TokenSequence;\r\n//# sourceMappingURL=TokenSequence.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TextRange_1 = require(\"./TextRange\");\r\nvar Token_1 = require(\"./Token\");\r\nvar Tokenizer = /** @class */ (function () {\r\n    function Tokenizer() {\r\n    }\r\n    /**\r\n     * Given a list of input lines, this returns an array of extracted tokens.\r\n     * The last token will always be TokenKind.EndOfInput.\r\n     */\r\n    Tokenizer.readTokens = function (lines) {\r\n        Tokenizer._ensureInitialized();\r\n        var tokens = [];\r\n        var lastLine = undefined;\r\n        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\r\n            var line = lines_1[_i];\r\n            Tokenizer._pushTokensForLine(tokens, line);\r\n            lastLine = line;\r\n        }\r\n        if (lastLine) {\r\n            tokens.push(new Token_1.Token(Token_1.TokenKind.EndOfInput, lastLine.getNewRange(lastLine.end, lastLine.end), lastLine));\r\n        }\r\n        else {\r\n            tokens.push(new Token_1.Token(Token_1.TokenKind.EndOfInput, TextRange_1.TextRange.empty, TextRange_1.TextRange.empty));\r\n        }\r\n        return tokens;\r\n    };\r\n    /**\r\n     * Returns true if the token is a CommonMark punctuation character.\r\n     * These are basically all the ASCII punctuation characters.\r\n     */\r\n    Tokenizer.isPunctuation = function (tokenKind) {\r\n        Tokenizer._ensureInitialized();\r\n        return Tokenizer._punctuationTokens[tokenKind] || false;\r\n    };\r\n    Tokenizer._pushTokensForLine = function (tokens, line) {\r\n        var buffer = line.buffer;\r\n        var end = line.end;\r\n        var bufferIndex = line.pos;\r\n        var tokenKind = undefined;\r\n        var tokenPos = bufferIndex;\r\n        while (bufferIndex < end) {\r\n            // Read a character and determine its kind\r\n            var charCode = buffer.charCodeAt(bufferIndex);\r\n            var characterKind = Tokenizer._charCodeMap[charCode];\r\n            if (characterKind === undefined) {\r\n                characterKind = Token_1.TokenKind.Other;\r\n            }\r\n            // Can we append to an existing token?  Yes if:\r\n            // 1. There is an existing token, AND\r\n            // 2. It is the same kind of token, AND\r\n            // 3. It's not punctuation (which is always one character)\r\n            if (tokenKind !== undefined\r\n                && characterKind === tokenKind\r\n                && Tokenizer._isMultiCharacterToken(tokenKind)) {\r\n                // yes, append\r\n            }\r\n            else {\r\n                // Is there a previous completed token to push?\r\n                if (tokenKind !== undefined) {\r\n                    tokens.push(new Token_1.Token(tokenKind, line.getNewRange(tokenPos, bufferIndex), line));\r\n                }\r\n                tokenPos = bufferIndex;\r\n                tokenKind = characterKind;\r\n            }\r\n            ++bufferIndex;\r\n        }\r\n        // Is there a previous completed token to push?\r\n        if (tokenKind !== undefined) {\r\n            tokens.push(new Token_1.Token(tokenKind, line.getNewRange(tokenPos, bufferIndex), line));\r\n        }\r\n        tokens.push(new Token_1.Token(Token_1.TokenKind.Newline, line.getNewRange(line.end, line.end), line));\r\n    };\r\n    /**\r\n     * Returns true if the token can be comprised of multiple characters\r\n     */\r\n    Tokenizer._isMultiCharacterToken = function (kind) {\r\n        switch (kind) {\r\n            case Token_1.TokenKind.Spacing:\r\n            case Token_1.TokenKind.AsciiWord:\r\n            case Token_1.TokenKind.Other:\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    Tokenizer._ensureInitialized = function () {\r\n        if (Tokenizer._charCodeMap) {\r\n            return;\r\n        }\r\n        Tokenizer._charCodeMap = {};\r\n        Tokenizer._punctuationTokens = {};\r\n        // All Markdown punctuation characters\r\n        var punctuation = Tokenizer._commonMarkPunctuationCharacters;\r\n        for (var i = 0; i < punctuation.length; ++i) {\r\n            var charCode = punctuation.charCodeAt(i);\r\n            Tokenizer._charCodeMap[charCode] = Token_1.TokenKind.OtherPunctuation;\r\n        }\r\n        // Special symbols\r\n        // !\"#$%&\\'()*+,\\-.\\/:;<=>?@[\\\\]^_`{|}~\r\n        var specialMap = {\r\n            '\\\\': Token_1.TokenKind.Backslash,\r\n            '<': Token_1.TokenKind.LessThan,\r\n            '>': Token_1.TokenKind.GreaterThan,\r\n            '=': Token_1.TokenKind.Equals,\r\n            '\\'': Token_1.TokenKind.SingleQuote,\r\n            '\"': Token_1.TokenKind.DoubleQuote,\r\n            '/': Token_1.TokenKind.Slash,\r\n            '-': Token_1.TokenKind.Hyphen,\r\n            '@': Token_1.TokenKind.AtSign,\r\n            '{': Token_1.TokenKind.LeftCurlyBracket,\r\n            '}': Token_1.TokenKind.RightCurlyBracket,\r\n            '`': Token_1.TokenKind.Backtick,\r\n            '.': Token_1.TokenKind.Period,\r\n            ':': Token_1.TokenKind.Colon,\r\n            ',': Token_1.TokenKind.Comma,\r\n            '[': Token_1.TokenKind.LeftSquareBracket,\r\n            ']': Token_1.TokenKind.RightSquareBracket,\r\n            '|': Token_1.TokenKind.Pipe,\r\n            '(': Token_1.TokenKind.LeftParenthesis,\r\n            ')': Token_1.TokenKind.RightParenthesis,\r\n            '#': Token_1.TokenKind.PoundSymbol,\r\n            '+': Token_1.TokenKind.Plus\r\n        };\r\n        for (var _i = 0, _a = Object.getOwnPropertyNames(specialMap); _i < _a.length; _i++) {\r\n            var key = _a[_i];\r\n            Tokenizer._charCodeMap[key.charCodeAt(0)] = specialMap[key];\r\n            Tokenizer._punctuationTokens[specialMap[key]] = true;\r\n        }\r\n        Tokenizer._punctuationTokens[Token_1.TokenKind.OtherPunctuation] = true;\r\n        var word = Tokenizer._wordCharacters;\r\n        for (var i = 0; i < word.length; ++i) {\r\n            var charCode = word.charCodeAt(i);\r\n            Tokenizer._charCodeMap[charCode] = Token_1.TokenKind.AsciiWord;\r\n        }\r\n        Tokenizer._charCodeMap[' '.charCodeAt(0)] = Token_1.TokenKind.Spacing;\r\n        Tokenizer._charCodeMap['\\t'.charCodeAt(0)] = Token_1.TokenKind.Spacing;\r\n    };\r\n    Tokenizer._commonMarkPunctuationCharacters = '!\"#$%&\\'()*+,\\-.\\/:;<=>?@[\\\\]^`{|}~';\r\n    Tokenizer._wordCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';\r\n    return Tokenizer;\r\n}());\r\nexports.Tokenizer = Tokenizer;\r\n//# sourceMappingURL=Tokenizer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar nodes_1 = require(\"../nodes\");\r\n/**\r\n * Renders a DocNode tree as plain text, without any rich text formatting or markup.\r\n */\r\nvar PlainTextRenderer = /** @class */ (function () {\r\n    function PlainTextRenderer() {\r\n    }\r\n    PlainTextRenderer.hasAnyTextContent = function (nodeOrNodes) {\r\n        if (nodeOrNodes instanceof nodes_1.DocNode) {\r\n            nodeOrNodes = [nodeOrNodes];\r\n        }\r\n        for (var _i = 0, nodeOrNodes_1 = nodeOrNodes; _i < nodeOrNodes_1.length; _i++) {\r\n            var node = nodeOrNodes_1[_i];\r\n            switch (node.kind) {\r\n                case \"FencedCode\" /* FencedCode */:\r\n                case \"CodeSpan\" /* CodeSpan */:\r\n                case \"EscapedText\" /* EscapedText */:\r\n                case \"LinkTag\" /* LinkTag */:\r\n                    return true;\r\n                case \"PlainText\" /* PlainText */:\r\n                    var docPlainText = node;\r\n                    // Is there at least one non-spacing character?\r\n                    if (docPlainText.text.trim().length > 0) {\r\n                        return true;\r\n                    }\r\n                    break;\r\n            }\r\n            if (node instanceof nodes_1.DocNodeContainer) {\r\n                for (var _a = 0, _b = node.getChildNodes(); _a < _b.length; _a++) {\r\n                    var childNode = _b[_a];\r\n                    if (this.hasAnyTextContent(childNode)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    return PlainTextRenderer;\r\n}());\r\nexports.PlainTextRenderer = PlainTextRenderer;\r\n//# sourceMappingURL=PlainTextRenderer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TrimSpacesTransform_1 = require(\"./TrimSpacesTransform\");\r\n/**\r\n * Helper functions that transform DocNode trees.\r\n */\r\nvar DocNodeTransforms = /** @class */ (function () {\r\n    function DocNodeTransforms() {\r\n    }\r\n    /**\r\n     * trimSpacesInParagraphNodes() collapses extra spacing characters from plain text nodes.\r\n     *\r\n     * @remark\r\n     * This is useful when emitting HTML, where any number of spaces are equivalent\r\n     * to a single space.  It's also useful when emitting Markdown, where spaces\r\n     * can be misinterpreted as an indented code block.\r\n     *\r\n     * For example, we might transform this:\r\n     *\r\n     * ```\r\n     * nodes: [\r\n     *   { kind: PlainText, text: \"   Here   are some   \" },\r\n     *   { kind: SoftBreak }\r\n     *   { kind: PlainText, text: \"   words\" },\r\n     *   { kind: SoftBreak }\r\n     *   { kind: InlineTag, text: \"{\\@inheritDoc}\" },\r\n     *   { kind: PlainText, text: \"to process.\" },\r\n     *   { kind: PlainText, text: \"  \" },\r\n     *   { kind: PlainText, text: \"  \" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * ...to this:\r\n     *\r\n     * ```\r\n     * nodes: [\r\n     *   { kind: PlainText, text: \"Here are some \" },\r\n     *   { kind: PlainText, text: \"words \" },\r\n     *   { kind: InlineTag, text: \"{\\@inheritDoc}\" },\r\n     *   { kind: PlainText, text: \"to process.\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * Note that in this example, `\"words \"` is not merged with the preceding node because\r\n     * its DocPlainText.excerpt cannot span multiple lines.\r\n     *\r\n     * @param docParagraph - a DocParagraph containing nodes to be transformed\r\n     * @returns The transformed child nodes.\r\n     */\r\n    DocNodeTransforms.trimSpacesInParagraph = function (docParagraph) {\r\n        return TrimSpacesTransform_1.TrimSpacesTransform.transform(docParagraph);\r\n    };\r\n    return DocNodeTransforms;\r\n}());\r\nexports.DocNodeTransforms = DocNodeTransforms;\r\n//# sourceMappingURL=DocNodeTransforms.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar nodes_1 = require(\"../nodes\");\r\nvar Excerpt_1 = require(\"../parser/Excerpt\");\r\n/**\r\n * Implementation of DocNodeTransforms.trimSpacesInParagraphNodes()\r\n */\r\nvar TrimSpacesTransform = /** @class */ (function () {\r\n    function TrimSpacesTransform() {\r\n    }\r\n    TrimSpacesTransform.transform = function (docParagraph) {\r\n        var transformedNodes = [];\r\n        // Whether the next nonempty node to be added needs a space before it\r\n        var pendingSpace = false;\r\n        // The DocPlainText node that we're currently accumulating\r\n        var accumulatedPlainTextNode = undefined;\r\n        // We always trim leading whitespace for a paragraph.  This flag gets set to true\r\n        // as soon as nonempty content is encountered.\r\n        var finishedSkippingLeadingSpaces = false;\r\n        for (var _i = 0, _a = docParagraph.nodes; _i < _a.length; _i++) {\r\n            var node = _a[_i];\r\n            switch (node.kind) {\r\n                case \"PlainText\" /* PlainText */:\r\n                    var docPlainText = node;\r\n                    var startedWithSpace = /^\\s/.test(docPlainText.text);\r\n                    var endedWithSpace = /\\s$/.test(docPlainText.text);\r\n                    var collapsedText = docPlainText.text.replace(/\\s+/g, ' ').trim();\r\n                    if (startedWithSpace && finishedSkippingLeadingSpaces) {\r\n                        pendingSpace = true;\r\n                    }\r\n                    if (collapsedText.length > 0) {\r\n                        if (accumulatedPlainTextNode) {\r\n                            // If this node can't be merged, then eject it\r\n                            if (!TrimSpacesTransform._canMergeExcerpts(accumulatedPlainTextNode.excerpt, docPlainText.excerpt)) {\r\n                                transformedNodes.push(new nodes_1.DocPlainText(accumulatedPlainTextNode));\r\n                                accumulatedPlainTextNode = undefined;\r\n                            }\r\n                        }\r\n                        // If we haven't started an accumulatedPlainTextNode, create it now\r\n                        if (!accumulatedPlainTextNode) {\r\n                            accumulatedPlainTextNode = {\r\n                                excerpt: undefined,\r\n                                text: ''\r\n                            };\r\n                        }\r\n                        if (pendingSpace) {\r\n                            accumulatedPlainTextNode.text += ' ';\r\n                            pendingSpace = false;\r\n                        }\r\n                        accumulatedPlainTextNode.text += collapsedText;\r\n                        accumulatedPlainTextNode.excerpt = TrimSpacesTransform._mergeExcerpts(accumulatedPlainTextNode.excerpt, docPlainText.excerpt);\r\n                        finishedSkippingLeadingSpaces = true;\r\n                    }\r\n                    if (endedWithSpace && finishedSkippingLeadingSpaces) {\r\n                        pendingSpace = true;\r\n                    }\r\n                    break;\r\n                case \"SoftBreak\" /* SoftBreak */:\r\n                    if (finishedSkippingLeadingSpaces) {\r\n                        pendingSpace = true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (pendingSpace) {\r\n                        // If we haven't started an accumulatedPlainTextNode, create it now\r\n                        if (!accumulatedPlainTextNode) {\r\n                            accumulatedPlainTextNode = {\r\n                                excerpt: undefined,\r\n                                text: ''\r\n                            };\r\n                        }\r\n                        accumulatedPlainTextNode.text += ' ';\r\n                        pendingSpace = false;\r\n                    }\r\n                    // Push the accumulated text\r\n                    if (accumulatedPlainTextNode) {\r\n                        transformedNodes.push(new nodes_1.DocPlainText(accumulatedPlainTextNode));\r\n                        accumulatedPlainTextNode = undefined;\r\n                    }\r\n                    transformedNodes.push(node);\r\n                    finishedSkippingLeadingSpaces = true;\r\n            }\r\n        }\r\n        // Push the accumulated text\r\n        if (accumulatedPlainTextNode) {\r\n            transformedNodes.push(new nodes_1.DocPlainText(accumulatedPlainTextNode));\r\n            accumulatedPlainTextNode = undefined;\r\n        }\r\n        var transformedParagraph = new nodes_1.DocParagraph({});\r\n        transformedParagraph.appendNodes(transformedNodes);\r\n        return transformedParagraph;\r\n    };\r\n    TrimSpacesTransform._canMergeExcerpts = function (currentExcerpt, followingExcerpt) {\r\n        if (currentExcerpt === undefined || followingExcerpt === undefined) {\r\n            return true;\r\n        }\r\n        if (!currentExcerpt.spacingAfterContent.isEmpty()\r\n            || !followingExcerpt.spacingAfterContent.isEmpty()) {\r\n            return false;\r\n        }\r\n        var currentSequence = currentExcerpt.content;\r\n        var followingSequence = followingExcerpt.content;\r\n        if (currentSequence.parserContext !== followingSequence.parserContext) {\r\n            return false;\r\n        }\r\n        return currentSequence.endIndex === followingSequence.startIndex;\r\n    };\r\n    TrimSpacesTransform._mergeExcerpts = function (currentExcerpt, followingExcerpt) {\r\n        if (currentExcerpt === undefined) {\r\n            return followingExcerpt;\r\n        }\r\n        if (followingExcerpt === undefined) {\r\n            return currentExcerpt;\r\n        }\r\n        if (!currentExcerpt.spacingAfterContent.isEmpty()\r\n            || !followingExcerpt.spacingAfterContent.isEmpty()) {\r\n            // This would be a program bug\r\n            throw new Error('mergeExcerpts(): Cannot merge excerpts with spacingAfterContent');\r\n        }\r\n        var currentSequence = currentExcerpt.content;\r\n        var followingSequence = followingExcerpt.content;\r\n        if (currentSequence.parserContext !== followingSequence.parserContext) {\r\n            // This would be a program bug\r\n            throw new Error('mergeExcerpts(): Cannot merge excerpts with incompatible parser contexts');\r\n        }\r\n        if (currentSequence.endIndex !== followingSequence.startIndex) {\r\n            // This would be a program bug\r\n            throw new Error('mergeExcerpts(): Cannot merge excerpts that are not adjacent');\r\n        }\r\n        return new Excerpt_1.Excerpt({\r\n            content: currentSequence.getNewSequence(currentSequence.startIndex, followingSequence.endIndex)\r\n        });\r\n    };\r\n    return TrimSpacesTransform;\r\n}());\r\nexports.TrimSpacesTransform = TrimSpacesTransform;\r\n//# sourceMappingURL=TrimSpacesTransform.js.map","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"body {\\r\\n  margin: '5px';\\r\\n  padding: 0;\\r\\n  font-family: sans-serif;\\r\\n}\\r\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","\nvar content = require(\"!!../node_modules/css-loader/index.js!./index.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./index.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./index.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import * as React from 'react';\r\nimport * as tsdoc from '@microsoft/tsdoc';\r\n\r\ninterface IPlaygroundViewProps {\r\n}\r\n\r\ninterface IPlaygroundViewState {\r\n  inputText: string;\r\n  outputText: string;\r\n  errorsText: string;\r\n}\r\n\r\nexport class PlaygroundView extends React.Component<IPlaygroundViewProps, IPlaygroundViewState>  {\r\n  private _reparseTimerHandle: number | undefined = undefined;\r\n  private _reparseNeeded: boolean = true;\r\n\r\n  constructor(props: IPlaygroundViewProps, context?: any) { // tslint:disable-line:no-any\r\n    super(props, context);\r\n\r\n    this.state = {\r\n      inputText:\r\n        [\r\n          '/**',\r\n          ' * Returns the average of two numbers.',\r\n          ' *',\r\n          ' * @remarks',\r\n          ' * This method is part of the {@link core-library#Statistics | Statistics subsystem}.',\r\n          ' *',\r\n          ' * @param x - The first input number',\r\n          ' * @param y - The second input number',\r\n          ' * @returns The arithmetic mean of `x` and `y`',\r\n          ' *',\r\n          ' * @beta',\r\n          ' */'\r\n        ].join('\\n'),\r\n      outputText: '',\r\n      errorsText: ''\r\n    };\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    this._reparseTimerHandle = setInterval(this._reparseTimer_onTick.bind(this), 700);\r\n  }\r\n\r\n  public componentWillUnmount(): void {\r\n    if (this._reparseTimerHandle !== undefined) {\r\n      clearInterval(this._reparseTimerHandle);\r\n      this._reparseTimerHandle = undefined;\r\n    }\r\n  }\r\n\r\n  public render(): React.ReactNode {\r\n    const textAreaStyle: React.CSSProperties = {\r\n      width: '600px',\r\n      height: '400px'\r\n    };\r\n    const errorsTextAreaStyle: React.CSSProperties = {\r\n      width: '1200px',\r\n      height: '200px'\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <textarea\r\n          id='input-textarea'\r\n          style={ textAreaStyle }\r\n          value={ this.state.inputText }\r\n          onChange={ this._inputTextArea_onChange.bind(this) }\r\n          />\r\n        <textarea\r\n          id='output-textarea'\r\n          readOnly={ true }\r\n          value={ this.state.outputText }\r\n          style={ textAreaStyle }\r\n          />\r\n        <br />\r\n        Errors:\r\n        <br />\r\n        <textarea\r\n          id='errors-textarea'\r\n          readOnly={ true }\r\n          value={ this.state.errorsText }\r\n          style={ errorsTextAreaStyle }\r\n          />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private _inputTextArea_onChange(event: React.ChangeEvent<HTMLTextAreaElement>): void {\r\n    this.setState({\r\n      inputText: event.target.value\r\n    });\r\n    this._reparseNeeded = true;\r\n  }\r\n\r\n  private _reparseTimer_onTick(): void {\r\n    if (!this._reparseNeeded) {\r\n      return;\r\n    }\r\n    this._reparseNeeded = false;\r\n    try {\r\n      const inputText: string = this.state.inputText;\r\n      const tsdocParser: tsdoc.TSDocParser = new tsdoc.TSDocParser();\r\n      const parserContext: tsdoc.ParserContext = tsdocParser.parseString(inputText);\r\n\r\n      const errorsText: string = parserContext.log.messages.map(x => x.toString()).join('\\n');\r\n\r\n      const outputLines: string[] = [];\r\n      if (parserContext.docComment) {\r\n        this._dumpTSDocTree(outputLines, parserContext.docComment);\r\n      }\r\n\r\n      this.setState({\r\n        outputText: outputLines.join('\\n'),\r\n        errorsText\r\n      });\r\n    } catch (error) {\r\n      this.setState({\r\n        outputText: '',\r\n        errorsText: 'Unhandled exception: ' + error.message\r\n      });\r\n    }\r\n  }\r\n\r\n  private _dumpTSDocTree(outputLines: string[], docNode: tsdoc.DocNode, indent: string = ''): void {\r\n    let dumpText: string = `${indent}- ${docNode.kind}`;\r\n    if (docNode instanceof tsdoc.DocNodeLeaf && docNode.excerpt) {\r\n      const content: string = docNode.excerpt.content.toString();\r\n      if (content.length > 0) {\r\n        dumpText += ': ' + JSON.stringify(content);\r\n      }\r\n    }\r\n    outputLines.push(dumpText);\r\n\r\n    for (const child of docNode.getChildNodes()) {\r\n      this._dumpTSDocTree(outputLines, child, indent + '  ');\r\n    }\r\n  }\r\n}\r\n","import * as React from 'react';\r\nimport { PlaygroundView } from './PlaygroundView';\r\n\r\nclass App extends React.Component {\r\n  public render(): React.ReactNode {\r\n\r\n    return (\r\n      <div>\r\n        <h1>TSDoc Playground</h1>\r\n\r\n        <PlaygroundView />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport './index.css';\r\n\r\nReactDOM.render(\r\n  <App />,\r\n  document.getElementById('root') as HTMLElement\r\n);\r\n","(function() { module.exports = this[\"React\"]; }());","(function() { module.exports = this[\"ReactDOM\"]; }());"],"sourceRoot":""}